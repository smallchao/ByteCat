{"meta":{"title":"ByteCat","subtitle":"探索数据的世界","description":null,"author":"Victor Wu","url":"https://smallchao.github.io","root":"/"},"pages":[{}],"posts":[{"title":"pytorch实现A2C","path":"1095588328/","date":"05-30","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"Actor-Critic算法","path":"3806206734/","date":"05-30","excerpt":"我们有了像Q-learning这么好的算法，为什么还要再折腾出一个Actor-Critic算法呢？原来，Actor-Critic算法中Actor的前身是Policy Gradients，这能让它毫不费力地在连续动作中选取合适的动作，而Q-learning做这件事会瘫痪。Critic的前身是Q-learning这类以值为基础的学习法，这让它能进行单步更新，而传统的Policy Gradients 是回合更新，学习效率比较低。正因为策略迭代法和价值迭代法各有各的优缺点，所以人们提出了Actor-Critic算法让两者结合到了一起，Actor来选择动作，Critic来告诉Actor它选择的动作是否合适。在这一过程中，Actor不断迭代，得到每一个状态下选择每一动作的合理概率，Critic也不断迭代，不断完善每个状态下选择每一个动作的奖惩值。"},{"title":"pytorch实现优先级经验回放机制","path":"1445223830/","date":"05-28","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch实现Dueling DQN","path":"3426131253/","date":"05-27","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch实现Double DQN","path":"4099349118/","date":"05-22","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch实现DQN","path":"2011684826/","date":"05-20","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度强化学习","path":"4188110411/","date":"05-17","excerpt":"表格表示问题在表格表示的Q学习中，表格行号对应于智能体的状态，列号对应于智能体的动作，表格中存储的是动作价值Q(s,a)。智能体的状态的状态很好理解。在迷宫任务中，智能体的状态是指所在的方块的位置，在倒立摆任务中，智能体的状态是对四个变量分别进行离散化转换成的数字值。智能体的动作是智能体可以采取的行动。在迷宫任务中，智能体可以在上下左右四个方向上移动，在倒立摆任务中，智能体可以在左右两个方向上移动。动作价值Q(st,at)是在时刻t、状态st下采取动作at时将获得的折扣奖励总和。表格表示的Q学习问题是，随着状态变量的类型数量增加，如果每个变量被精细地离散化，则表格中的行数会变得很大。例如，当以图像作为状态时，每个像素对应于状态变量，状态变量的数量变得非常大。50像素的方形图像将具有多达2500个状态变量。为了使用包含许多行的表格表示来适当地进行强化学习，需要做大量的实验。因此，用表格表示的强化学习解决具有大型状态的任务是不现实的。"},{"title":"gym环境下训练倒立摆","path":"699896311/","date":"05-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用价值迭代法走迷宫（2）","path":"1153787513/","date":"05-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用价值迭代法走迷宫（1）","path":"1450232215/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用策略迭代法走迷宫","path":"1256595214/","date":"05-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"随机搜索走迷宫","path":"3153300902/","date":"05-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"强化学习构成要素","path":"808510049/","date":"05-02","excerpt":"强化学习的主要构成要素包括：智能体、环境、行动、奖励。智能体（Agent）智能体是可以采取行动的智能个体。环境（Environment）环境指的就是智能体行走于其中的世界。环境的输入是智能体当前的状态和行动，输出是智能体的奖励和智能体下一步的状态。"},{"title":"强化学习概述","path":"2012735660/","date":"05-01","excerpt":"当一个孩子学习骑自行车时，并没有人去教其诸如牛顿力学等力学法则以及如何骑车的详细方法，也不必通过观看视频来学习骑自行车。事实上，自己尝试骑自行车，在多次失败的过程中找到一种骑自行车的方法。强化学习正如骑自行车的例子，它是一种学习方法，它在不知道控制对象的物理定律的情况下重复试错，以学习到所希望的控制方法。"},{"title":"半监督学习算法（3）-- 聚类","path":"2652695742/","date":"04-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"半监督学习算法（2）-- 分类","path":"3905662131/","date":"04-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"半监督学习算法（1）","path":"660866816/","date":"04-01","excerpt":"无监督学习只利用未标记的样本集，而监督学习则只利用标记的样本集进行学习。但在很多实际问题中，只有少量的带有标记的数据，因为对数据进行标记的代价有时很高，比如在生物学中，对某种蛋白质的结构分析或者功能鉴定，可能会花上生物学家很多年的工作，而大量的未标记的数据却很容易得到，这就促使能同时利用标记样本和未标记样本的半监督学习技术迅速发展起来。"},{"title":"用LSTM预测股票价格","path":"564105494/","date":"01-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"Auto-Arima工具包","path":"214610947/","date":"01-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"自回归模型","path":"611143796/","date":"01-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"时间序列预处理（2）","path":"192315576/","date":"01-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"时间序列预处理（1）","path":"432222038/","date":"01-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"什么是时间序列","path":"1342494407/","date":"01-05","excerpt":"时间序列是按时间顺序索引的一系列数据点，通常是在相等间隔的时间段内依照给定的采样率对某种潜在过程进行观测的结果。时间序列数据本质上反映的是某个或者某些随机变量随时间不断变化的趋势，而时间序列预测方法的核心就是从数据中挖掘出这种规律，并利用其对将来的数据做出估计。典型的时间序列包含以下几种构成要素："},{"title":"循环生成对抗网络CycleGAN","path":"3809137533/","date":"12-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"超分辨率技术（6）","path":"2250709945/","date":"12-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"超分辨率技术（5）","path":"2492642391/","date":"12-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"超分辨率技术（4）","path":"741266226/","date":"12-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"超分辨率技术（3）","path":"2985945995/","date":"12-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"超分辨率技术（2）","path":"155553006/","date":"12-03","excerpt":""},{"title":"超分辨率技术（1）","path":"468722432/","date":"12-03","excerpt":"图像分辨率图像分辨率指图像中存储的信息量，指的是每英寸图像内有多少个像素点，分辨率的单位为PPI（Pixels Per Inch），通常叫做像素每英寸。一般情况下，图像分辨率越高，图像中包含的细节就越多，信息量也越大。图像分辨率分为空间分辨率和时间分辨率。通常，分辨率被表示成每一个方向上的像素数量，例如64×64的二维图像。但分辨率的高低其实并不等同于像素数量的多少，例如一个通过插值放大了5倍的图像并不表示它包含的细节增加了多少。图像超分辨率重建关注的是恢复图像中丢失的细节，即高频信息。 在大量的电子图像应用领域，人们经常期望得到高分辨率（简称HR）图像。但由于设备、传感器等原因，我们得到的图像往往是低分辨率图像（LR）。增加空间分辨率最直接的解决方法就是通过传感器制造技术减少像素尺寸（例如增加每单元面积的像素数量）；另外一个增加空间分辨率的方法是增加芯片的尺寸，从而增加图像的容量。因为很难提高大容量的偶合转换率，所以这种方法一般不认为是有效的，因此，引出了图像超分辨率技术。"},{"title":"边界平衡生成对抗网络BEGAN","path":"2605364840/","date":"12-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"条件生成对抗网络CGAN","path":"2536535457/","date":"12-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"全卷积的生成对抗网络DCGAN","path":"2708801932/","date":"12-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用基础GAN实现手写数字生成","path":"856187095/","date":"12-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"生成对抗网络介绍","path":"3844694714/","date":"12-01","excerpt":"生成对抗网络(GANs)是一种由两个相互竞争的网络组成的深度神经网络架构。一、生成模型和判别模型为了理解生成对抗网络，首先应该了解生成算法的是如何工作的，为此，现将生成算法和判别算法进行对比以便更好的理解。"},{"title":"从视频中提取音频","path":"1324599265/","date":"11-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"文本转换成语音","path":"1510560744/","date":"11-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"Transformer","path":"3771864186/","date":"11-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"从静态词向量到动态词向量","path":"3371179689/","date":"11-12","excerpt":"静态词向量指的是一个单词用一个唯一的词向量表示并不考虑上下文的变化，它最大的缺点是无法表达多意性。为了解决一词多意的问题，使得词向量能根据上下文语境进行动态调整，于是便有了动态词向量。典型的动态词向量模型包括elmo、GPT、Bert。"},{"title":"使用LSTM实现手写数字识别","path":"2999619984/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用LSTM实现词性标注","path":"998189118/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"长短期记忆网络LSTM（2）","path":"1432716653/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"长短期记忆网络LSTM（1）","path":"413325780/","date":"11-09","excerpt":"在处理序列信息中我们已经有了RNN，但是在实践中发现，RNN只能存储短期记忆，也就是说只能理解上下文，而不能把握整篇的全部内容。因此，我们就需要能够长期记忆的模型。LSTM全称为Long Short-Term Memory，即长短期记忆网络。它是一种特殊的RNN网络，该网络设计出来是为了解决长依赖问题。该网络由Hochreiter &amp; Schmidhuber引入，并有许多人对其进行了改进和普及。"},{"title":"使用字符级RNN生成姓名","path":"3887497534/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用字符级RNN对姓名进行分类","path":"3773272045/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"循环神经网络RNN（2）","path":"2773379099/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"循环神经网络RNN（1）","path":"3086731253/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"社交评论区文本情感分析","path":"1695927846/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用gensim加载预训练词向量（2）","path":"2484505602/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用gensim加载预训练词向量（1）","path":"2258838508/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用gensim训练词向量","path":"3927750096/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch训练Skip-Gram模型","path":"554339283/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch训练CBOW模型","path":"3959549679/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch训练Glove模型","path":"881507429/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"词的表示（3）-- 分布表示","path":"3489153463/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"词的表示（2）-- 离散表示","path":"696615159/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"词的表示（1）","path":"3092791979/","date":"11-06","excerpt":"把分词之后的字和词语表示成计算机能够计算的类型（向量），这就是所谓的词的表示。离散化表示（Discrete Representation）不考虑文本中词与词之间的关系，忽略复杂的语义关系归结为简单的向量结构，典型代表是词袋模型。这种方法解释性很强，我们知道每一维特征对应哪一个词，进而我们还可以使用TF-IDF对各个词特征的权重修改，进一步完善特征的表示。"},{"title":"工业级自然语言处理工具spaCy","path":"2239988567/","date":"11-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用nltk做英文词干提取","path":"1480476203/","date":"11-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用snownlp做情感分析","path":"3468397237/","date":"11-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用jieba标注词性","path":"4126685437/","date":"11-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"文本预处理工具之关键词替换","path":"2635558291/","date":"11-01","excerpt":""},{"title":"文本预处理之停用词过滤","path":"1315666372/","date":"11-01","excerpt":""},{"title":"文本预处理之分词（2）","path":"1591881499/","date":"11-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"文本预处理之分词（1）","path":"1280803061/","date":"11-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"英文分词工具","path":"343283924/","date":"11-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"中文分词工具","path":"602045579/","date":"11-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"分词算法","path":"2428217240/","date":"11-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"文本预处理之中英文翻译","path":"1942368022/","date":"10-01","excerpt":""},{"title":"文本预处理之文档汇总","path":"1691828925/","date":"10-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型协同过滤（2）-- 矩阵分解","path":"1737041926/","date":"09-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型协同过滤（1）-- 关联规则","path":"3233456185/","date":"09-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"物品协同过滤","path":"1363519369/","date":"09-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用户协同过滤","path":"1705595773/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于内容的推荐","path":"3429841512/","date":"09-01","excerpt":"一、概念基于内容的推荐算法（Content-Based Recommendations ，CB）理论依据主要来自于信息检索和信息过滤，是最早被使用的推荐算法，它的思想非常简单：根据用户过去喜欢的物品（item），为用户推荐和他过去喜欢的物品相似的物品。而关键就在于这里的物品相似性的度量，这才是算法运用过程中的核心。举个例子来说，在音乐网站或者资讯网站注册过程中用户需要选择自己的兴趣标签，这就是为了把合适的内容推荐给用户。需要注意的是物品的特征抽取一般很难。如果系统中的物品是文档（如个性化阅读中），那么我们现在可以比较容易地使用信息检索里的方法来”比较精确地”抽取出物品的特征。但很多情况下我们很难从物品中抽取出准确刻画物品的特征，比如电影推荐中物品是电影，社会化网络推荐中物品是人，这些物品属性都不好抽。其实，几乎在所有实际情况中我们抽取的物品特征都仅能代表物品的一些方面，不可能代表物品的所有方面。"},{"title":"国密算法（3）","path":"342408640/","date":"08-02","excerpt":""},{"title":"国密算法（2）","path":"2899630757/","date":"08-02","excerpt":""},{"title":"国密算法（1）","path":"3194058059/","date":"08-02","excerpt":"算法名称 算法类别 应用领域 特点 SM1 对称（分组）加密算法 芯片 分组长度、密钥长度均为128比特 SM2 非对称（基于椭圆曲线 ECC）加密算法 数据加密 密钥长度192-256比特的ECC椭圆曲线密码 SM3 散列（hash）函数算法 完整性校验 安全性及效率与SHA-256相当，压缩函数更复杂 SM4 对称（分组）加密算法 数据加密和局域网产品 分组长度、密钥长度均为128比特，计算轮数多 SM7 对称（分组）加密算法 非接触式IC卡 分组长度、密钥长度均为128比特 SM9 标识加密算法（IBE） 端对端离线安全通讯 加密强度等同于3072位密钥的RSA加密算法 ZUC 对称（序列）加密算法 移动通信4G网络 流密码"},{"title":"数字签名技术（2）","path":"620140195/","date":"08-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"数字签名技术（1）","path":"910375245/","date":"08-01","excerpt":"数字签名在ISO7498—2标准中定义为：”附加在数据单元上的一些数据，或是对数据单元所作的密码变换，这种数据和变换允许数据单元的接收者用以确认数据单元来源和数据单元的完整性，并保护数据，防止被人（例如接收者）进行伪造。”数字签名要实现的功能是我们平常的手写签名要实现功能的扩展。平常在书面文件上签名的主要作用有两点，一是因为对自己的签名本人难以否认，从而确定了文件已被自己签署这一事实；二是因为自己的签名不易被别人模仿，从而确定了文件是真的这一事实。采用数字签名，也要完成这些功能：（1）确认信息是由签名者发送的；（2）确认信息自签名后到收到为止，未被修改过；（3）签名者无法否认信息是由自己发送的。数字签名的技术基础是非对称密钥加密技术与数字摘要技术。"},{"title":"消息摘要算法（3）-- SHA","path":"672985995/","date":"08-01","excerpt":""},{"title":"消息摘要算法（2）-- MD5","path":"716958950/","date":"08-01","excerpt":""},{"title":"消息摘要算法（1）","path":"2573065078/","date":"08-01","excerpt":"什么是消息摘要算法消息摘要算法（MessageDigest）是密码学算法中非常重要的一个分支，它通过对所有数据提取指纹信息以实现数据完整性校验等功能。 消息摘要算法和哈希算法的关系信息摘要算法其实就是哈希算法的一种，但拥有额外的更严格的条件，例如运算不可逆、更严格的碰撞要求等。"},{"title":"python的非对称加密模块rsa","path":"3990411509/","date":"07-27","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非对称加密之RSA","path":"1340323011/","date":"07-26","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"对称加密之RC4","path":"3366670061/","date":"07-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"对称加密之AES","path":"1397162169/","date":"07-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"对称加密之DES","path":"1435288146/","date":"07-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"对称加密和非对称加密","path":"2225813696/","date":"07-22","excerpt":"现代的数字加密算法可划分为对称加密和非对称加密两种。对称加密对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。常见的对称加密算法有DES、3DES、AES、RC4、RC5、RC6"},{"title":"现代密码体制的萌芽","path":"3164395228/","date":"07-19","excerpt":"维尔南（Vernam）密码被视为是现代密码体制的萌芽。它是美国电话电报公司的Gilbert Vernam在1917年为电报通信设计的一种非常方便的密码，在近代计算机和通信系统设计中得到了广泛应用。维尔南密码的特点是通过一个密钥流生成器（key stream generator）来持续生成二进制密钥。密钥文件大小与待加密文件大小相同（精确到字节）。换言之，待加密文件越大，密钥文件越大，加密强度越高！举个例子，如果想加密一个5M的文件，那么密钥长度将高达40,000,000位，输出文件大小则仍为5M。想要在”有生之年”靠穷取法破解出密码，几乎不可能完成的任务。"},{"title":"古典密码之栅栏密码","path":"3873992564/","date":"07-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"古典密码之维吉尼亚密码","path":"2603191500/","date":"07-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"古典密码之仿射密码","path":"3219454337/","date":"06-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"古典密码之摩斯密码","path":"3597826960/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"古典密码之简单替换密码","path":"2708233208/","date":"06-03","excerpt":"该密码在加密时，将每个明文字母替换为与之唯一对应且不同的字母，解密时逆向查表即可。它与凯撒密码之间的区别是其密码字母表的字母不是简单的移位，而是完全是混乱的，这也使得其破解难度要高于凯撒密码。"},{"title":"古典密码之凯撒密码","path":"2806980039/","date":"06-02","excerpt":""},{"title":"密码学基本概念","path":"2443475287/","date":"06-01","excerpt":"密码学（Cryptography），是一门将信息进行加密处理与传递，以及分析加密信息的学科。密码学早期比较常见于军事领域，后来逐渐延申到电子商务、银行支付、数字版权等等社会关键民生领域，说密码学是当代社会的一个支柱并不为过。"},{"title":"点云数据处理（2）","path":"616778257/","date":"04-23","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"点云数据处理（1）","path":"913761791/","date":"04-23","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"拓扑数据分析包Gudhi","path":"2238448128/","date":"04-20","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"地理处理包GeoPandas","path":"3319907697/","date":"04-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"地理处理包Shapely","path":"599173226/","date":"04-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【体】计算三维空间三角形面积","path":"2598970177/","date":"04-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【体】计算三维空间垂足点坐标","path":"2140013241/","date":"04-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【体】三维空间向量之间的夹角","path":"1746369574/","date":"04-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】二维空间索引之RTree","path":"1595559653/","date":"03-23","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】一维空间索引之Google S2","path":"700104209/","date":"03-22","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】一维空间索引之GeoHash","path":"562791177/","date":"03-22","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】三角形的外接圆和内切圆","path":"3551841744/","date":"02-24","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】用射线法判断点是否在多边形区域内部","path":"1881751274/","date":"02-24","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】计算点到直线的距离","path":"895554260/","date":"02-22","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】计算两向量之间的夹角","path":"209100171/","date":"02-22","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】计算两圆的交点坐标","path":"3906467213/","date":"02-20","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】判断两线段是否相交","path":"1938740148/","date":"02-20","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】判断两个矩形是否相交","path":"2050743542/","date":"02-20","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】判断两个圆是否相交","path":"809244184/","date":"02-20","excerpt":""},{"title":"【面】到各点距离和最小的位置","path":"2678846222/","date":"02-16","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】计算地图上多个坐标围成区域的中心点","path":"219240351/","date":"02-16","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】计算任意二维图形的面积","path":"3800291106/","date":"02-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】计算三角形的面积","path":"1120355887/","date":"02-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【面】周长最小的外接多边形","path":"946033335/","date":"02-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】路径规划","path":"1394255694/","date":"02-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】轨迹插值","path":"234769881/","date":"02-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】轨迹平滑","path":"3333338910/","date":"02-08","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】轨迹相似度","path":"3350700085/","date":"02-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】轨迹抽稀","path":"1291418498/","date":"02-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】最佳直线","path":"2608295803/","date":"01-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】缀点成线","path":"2215806983/","date":"01-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】坐标推算","path":"4247073345/","date":"01-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【线】计算方向角","path":"2008376300/","date":"01-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】基站定位","path":"2399736275/","date":"01-08","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】三角定位","path":"3000922295/","date":"01-08","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】兴趣点周边检索","path":"3538749538/","date":"01-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】地理编码和逆地理编码","path":"1905793239/","date":"01-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】地理坐标系统与投影坐标系统","path":"3213075293/","date":"01-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】两个笛卡尔坐标系之间的转换","path":"3905244915/","date":"01-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】计算两坐标之间的球面距离","path":"1478578393/","date":"01-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】笛卡尔坐标到极坐标的转换","path":"4178351287/","date":"01-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】三维空间坐标变换","path":"2350984182/","date":"01-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】二维空间坐标变换","path":"708710367/","date":"01-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【点】笛卡尔坐标与齐次坐标","path":"3076401971/","date":"01-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch-geometric训练GAT","path":"222082270/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch-geometric训练GCN","path":"3261607718/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pytorch-geometric安装","path":"1340078303/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（10）","path":"258077177/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（9）","path":"3928370608/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（8）","path":"1385843413/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（7）","path":"184113795/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（6）","path":"2990882278/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（5）","path":"2700120584/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（4）","path":"407696749/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（3）","path":"2241580500/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（2）","path":"1026009777/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络工具库DGL（1）","path":"798098783/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于GAT的半监督分类","path":"2796214471/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于GraghSAGE的半监督分类","path":"1400526220/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于GCN的半监督分类","path":"36933173/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图神经网络初探","path":"4183824667/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图嵌入简介","path":"2573480427/","date":"12-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用networkx分析复杂网络","path":"1499959811/","date":"11-09","excerpt":""},{"title":"复杂网络（3）","path":"606296812/","date":"11-09","excerpt":"实际网络都兼有确定和随机两大特征，确定性的法则或特征通常隐藏在统计性质中。人们在刻画复杂网络结构的统计特性上提出了许多概念和方法，其中包含：节点的度和度分布、平均路径长度、聚集系数。"},{"title":"复杂网络（2）","path":"2627681673/","date":"11-09","excerpt":""},{"title":"复杂网络（1）","path":"2385154663/","date":"11-09","excerpt":""},{"title":"networkx搭配Neo4j","path":"2223129561/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用networkx解决图论问题（3）","path":"1405595896/","date":"11-09","excerpt":"在人员分派问题中，工作人员适合做的各项工作效益未必一致，需要制订一个分派方案，使公司总效益最大。解决这个问题可以用库恩-曼克莱斯（Kuhn-Munkres）算法。"},{"title":"用networkx解决图论问题（2）","path":"3950761885/","date":"11-09","excerpt":"例：已知8口油井相互之间的距离如下表所示。其中1号油井离海岸最近，为5nmile（1nmile = 1.852km）。问从海岸经1号油井铺设油管将各油井连接起来，应如何铺设使油管长度最短。"},{"title":"用networkx解决图论问题（1）","path":"4191058035/","date":"11-09","excerpt":"设备更新问题例：某种工程设备的役龄为4年，每年年初都面临着是否更新的问题：若卖旧买新，就要支付一定的购置费用；若继续使用，则要支付更多的维护费用，且使用年限越长维护费用越多。若役龄期内每年的年初购置价格、当年维护费用及年末剩余净值如下表所示。"},{"title":"图分析工具库networkx","path":"2013522379/","date":"11-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图算法之中心性","path":"2526592597/","date":"11-08","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"求解旅行商问题专用工具elkai","path":"4056310935/","date":"11-07","excerpt":"elkai是python的第三方库，专门用于解决TSP问题，目前已知能够在规模达到315个节点的问题中求解出最优方案。elkai本身的实现基于大名鼎鼎的LKH算法，该算法被认为是目前解决TSP问题最有效的算法。"},{"title":"自适应大邻域搜索算法解决旅行商问题","path":"3540365369/","date":"11-07","excerpt":""},{"title":"蚁群算法解决旅行商问题","path":"1337251149/","date":"11-07","excerpt":""},{"title":"遗传算法解决旅行商问题","path":"37981038/","date":"11-07","excerpt":""},{"title":"禁忌搜索算法解决旅行商问题","path":"2033053322/","date":"11-07","excerpt":""},{"title":"模拟退火算法解决旅行商问题","path":"2429411842/","date":"11-07","excerpt":""},{"title":"哈密顿回路与旅行商问题","path":"3608274885/","date":"11-07","excerpt":"哈密顿路径、哈密顿回路、哈密顿图G=(V,E)是一个图，若G中一条路径通过且仅通过每一个顶点一次，称这条路径为哈密顿路径。若G中一个回路通过且仅通过每一个顶点一次，称这个环为哈密顿回路。若一个图存在哈密顿回路，就称为哈密顿图。"},{"title":"用Astar算法实现走迷宫","path":"1330882104/","date":"11-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用Astar算法实现地铁换乘规划（2）","path":"3625469554/","date":"11-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用Astar算法实现地铁换乘规划（1）","path":"3400395164/","date":"11-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用Dijkstra算法实现地铁换乘规划","path":"2413565653/","date":"11-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图算法之最短路径","path":"3934172265/","date":"11-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图算法之最小生成树","path":"3463015404/","date":"11-05","excerpt":"将给出的所有点连接起来（即从一个点可到任意一个点）且连接路径之和最小的图叫最小生成树。要解决最小生成树问题，通常采用两种算法：Prim算法和Kruskal算法。一般来说，prim算法适合稠密图，kruskal算法适合稀疏图。"},{"title":"图算法之连通分量","path":"4149357912/","date":"11-04","excerpt":""},{"title":"图算法之遍历","path":"3932555124/","date":"11-03","excerpt":"两种图的遍历算法：广度优先（BFS）与深度优先（DFS）。广度优先遍历的路径通常短而直接，深度优先遍历的路径通常长而曲折。广度优先遍历从起点开始，遍历所有与起点连通的顶点，再遍历与这些顶点连通的顶点，即先搜索距离起点距离为1的顶点，再遍历与起点距离为2的顶点….."},{"title":"获取社交网络中的N度好友关系","path":"3504925792/","date":"11-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"python构造图的方法","path":"938875486/","date":"11-02","excerpt":"只要各顶点及边都确定了，就可以构建出图。一、图类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Graph: def __init__(self, vertices=[], matrix=[]): ''' 图的初始化 ''' self.vertices = vertices self.matrix = matrix self.edges_dict = &#123;&#125; # &#123;(tail, head): weight&#125; self.edges_array = [] # (tail, head, weight) if self.matrix == []: self.matrix = [[0 for col in range(len(self.vertices))] for row in range(len(self.vertices))] self.add_edges_from_matrix() def add_vertex(self, key): ''' 添加顶点 ''' if key not in self.vertices: self.vertices.append(key) for i in range(len(self.vertices)-1): self.matrix[i].append(0) nRow = [0] * len(self.vertices) self.matrix.append(nRow) def add_edge(self, tail, head, cost=1): ''' 添加边 ''' if tail not in self.vertices: self.add_vertex(tail) if head not in self.vertices: self.add_vertex(head) self.matrix[self.vertices.index(tail)][self.vertices.index(head)] = cost self.edges_dict[(tail, head)] = cost self.edges_array.append((tail, head, cost)) def add_edges_from_list(self, edges_list): ''' 从列表中获取边集 ''' self.edges_dict = &#123;&#125; self.edges_array = [] for i in range(len(edges_list)): self.add_edge(edges_list[i][0], edges_list[i][1], edges_list[i][2]) self.edges_array.append([edges_list[i][0], edges_list[i][1], edges_list[i][2]]) def add_edges_from_matrix(self): ''' 从邻接矩阵中获取边集 ''' self.edges_dict = &#123;&#125; self.edges_array = [] for i in range(len(self.matrix)): for j in range(len(self.matrix)): if 0 &lt; self.matrix[i][j] &lt; float('inf'): self.edges_dict[self.vertices[i], self.vertices[j]] = self.matrix[i][j] self.edges_array.append([self.vertices[i], self.vertices[j], self.matrix[i][j]])"},{"title":"图的基本概念","path":"582804967/","date":"11-01","excerpt":"图是一种非常神奇的表示方式，生活中绝大多数的现象或情境都能用图来表示，例如人际关系网、道路交通网、信息互联网等等。正如马哲介绍事物具有普遍联系性，而图正好能捕捉这种联系，所以用它来描述这个世界是再好不过的方法。"},{"title":"人物视频抠像模型","path":"1957207064/","date":"09-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"提取场景中的文字（3）","path":"3902190320/","date":"09-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"提取场景中的文字（2）","path":"1344984469/","date":"09-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"提取场景中的文字（1）","path":"1117747835/","date":"09-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"人脸检测的衍生应用：制作平均脸","path":"2650166905/","date":"09-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"人脸检测技术（3）-- 深度学习方法","path":"3874971734/","date":"09-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"人脸检测技术（2）-- 传统方法","path":"2643426997/","date":"09-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"人脸检测技术（1）","path":"869374503/","date":"09-11","excerpt":"人脸检测的概念人脸检测指的是检测出图片中的人脸，并能够标示出人脸的位置。人脸检测技术主要完成了两件工作：第一，判断图片中是否包含人脸区域；第二，如果图片中存在人脸，将人脸的位置标识出来。"},{"title":"目标跟踪技术（3）-- 光流法","path":"205787146/","date":"09-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"目标跟踪技术（2）-- 背景差分法","path":"1147178723/","date":"09-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"目标跟踪技术（1）","path":"1552247859/","date":"09-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"注意力机制的应用示例（2）","path":"1220070078/","date":"09-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"注意力机制的应用示例（1）","path":"3662773769/","date":"09-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像注意力机制","path":"1254556825/","date":"09-04","excerpt":"注意力机制（Attention Mechanism）源于对人类视觉的研究。在认知科学中，由于信息处理的瓶颈，人类会选择性地关注所有信息的一部分，同时忽略其他可见的信息。上述机制通常被称为注意力机制。人类视网膜不同的部位具有不同程度的信息处理能力，即敏锐度（Acuity），只有视网膜中央凹部位具有最强的敏锐度。为了合理利用有限的视觉信息处理资源，人类需要选择视觉区域中的特定部分，然后集中关注它。例如，人们在阅读时，通常只有少量要被读取的词会被关注和处理。综上，注意力机制主要有两个方面："},{"title":"分分钟实现图像分割的库PixelLib","path":"224721115/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"实现基于SegNet的图像语义分割","path":"3314154675/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"实现基于聚类的图像分割","path":"1486743620/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"从目标检测到语义分割","path":"1567870008/","date":"09-03","excerpt":"目标检测方法可以帮助我们绘制某些确定实体的边框，但人类对场景的理解能以像素级的精细程度对每一个实体进行检测并标记精确的边界。我们已经开始发展自动驾驶汽车和智能机器人，这些都需要深入理解周围环境，因此精确分割实体变得越来越重要。语义分割是计算机视觉中的基本任务，在语义分割中我们需要将视觉输入分为不同的语义可解释类别，「语义的可解释性」即分类类别在真实世界中是有意义的。例如，我们可能需要区分图像中属于汽车的所有像素，并把这些像素涂成蓝色。"},{"title":"利用Flask部署目标检测模型","path":"3235170785/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"anchor-free之YOLOX","path":"16136706/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"anchor-free之CenterNet（4）","path":"317908413/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"anchor-free之CenterNet（3）","path":"2401623300/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"anchor-free之CenterNet（2）","path":"932821601/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"anchor-free之CenterNet（1）","path":"623646095/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"anchor-based和anchor-free","path":"1373608216/","date":"09-03","excerpt":"一、综述目标检测算法一般可分为anchor-based、anchor-free两大类，区别就在于有没有利用anchor提取候选目标框。二、anchor-based与anchor-free"},{"title":"封装目标检测数据预处理流程","path":"66522009/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"目标检测图像增广","path":"3516014905/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"泛用性更强的目标检测数据提取功能","path":"3823060126/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"实现一个目标检测项目","path":"3550762351/","date":"09-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"真实框、预测框和锚框的可视化","path":"3899028144/","date":"09-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"目标检测中的框合并策略nms及其改进","path":"2445347190/","date":"09-01","excerpt":"检测算法可能对同一目标产生多次检测的结果，这就需要使用某些算法对检测框去重。常用的两种算法是NMS和Soft-NMS。NMSNMS（non maximum suppression，非极大值抑制）算法思想很简单，按照分类概率排序，概率最高的框作为候选框，其它所有与它的IOU高于一个阈值（这是人工指定的超参）的框其概率被置为0。然后在剩余的框里寻找概率第二大的框，其它所有与它的IOU高于一个阈值（这是人工指定的超参）的框其概率被置为0。依次类推。最终所有的框相互之间的IOU都是小于超参阈值的，或者概率被置为0了。剩下的所有概率非0的框就是最终的检测框。"},{"title":"目标检测基础模块之IoU及其改进","path":"3627155151/","date":"09-01","excerpt":"一、IoU简介IoU又名交并比，是一种计算不同图像相互重叠比例的算法，时常被用于深度学习领域的目标检测或语义分割任务中。 1、在目标检测中的应用2、在语义分割中的应用"},{"title":"从图像识别到目标检测","path":"562227813/","date":"09-01","excerpt":"图像识别是将图像划分为单个类别，通常对应于图像中最突出的物体。但是现实世界的很多图像通常包含的不只是一个物体，此时如果使用图像识别模型为图像分配一个单一标签其实是非常粗糙的，并不准确。对于这样的情况，就需要目标检测（object detection）。目标检测简单来说就是在图像识别的基础上，以包围盒（bounding box）的形式把物体框出来。目标检测在很多场景有用，如无人驾驶和安防系统。"},{"title":"卷积神经网络学习经验可视化","path":"2176112566/","date":"08-26","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"利用Flask部署图像识别模型","path":"3750824576/","date":"08-26","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"让网络适应任何大小的输入图","path":"1980971698/","date":"08-26","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用轻量化网络训练分类模型","path":"1260346949/","date":"08-26","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"实现一个验证码识别项目","path":"2480160266/","date":"08-26","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"实现一个猫狗识别项目","path":"391323939/","date":"08-26","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"实现一个手写数字识别项目","path":"4049078704/","date":"08-25","excerpt":"MNIST手写数字识别项目因为数据量小识别任务简单而成为图像识别入门的第一课。MNIST数据集包括6万张28x28的训练样本，1万张测试样本。1、数据查看1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import numpy as npimport matplotlib.pyplot as pltimport torchimport torchvision as tvfrom torchvision import transforms#========================================================# 超参数设置#========================================================# 批处理尺寸(batch_size)BATCH_SIZE = 20 # 定义图像类别classes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']#========================================================# 数据加工#========================================================# 定义数据预处理方式transform = transforms.Compose([ transforms.ToTensor(), # 将图片(Image)转化为Tensor, 归一化到[0,1] transforms.Normalize(mean=[0.5], std=[0.5]) # 标准化到[-1,1] ])# 定义训练数据集trainset = tv.datasets.MNIST( root='./data/', train=True, download=True, transform=transform)# 定义训练批处理数据trainloader = torch.utils.data.DataLoader( trainset, batch_size=BATCH_SIZE, shuffle=True )#========================================================# 查看原始图像#======================================================== # 获取一个批次的训练数据dataiter = iter(trainloader)images, labels = dataiter.next()images = images.numpy()# 打印图片配上相应的标签fig = plt.figure(figsize=(25, 4))for idx in np.arange(BATCH_SIZE): ax = fig.add_subplot(2, BATCH_SIZE/2, idx+1, xticks=[], yticks=[]) ax.imshow(np.squeeze(images[idx]), cmap='gray') ax.set_title(classes[labels[idx]])plt.show()#========================================================# 查看归一化后的图像#========================================================idx = 2img = np.squeeze(images[idx])fig = plt.figure(figsize = (12,12)) ax = fig.add_subplot(111)ax.imshow(img, cmap='gray')width, height = img.shapethresh = img.max()/2.5for x in range(width): for y in range(height): val = round(img[x][y],2) if img[x][y] !=0 else 0 ax.annotate(str(val), xy=(y,x), horizontalalignment='center', verticalalignment='center', color='white' if img[x][y]&lt;thresh else 'black')plt.show()"},{"title":"图像数据的非线性增强方法","path":"2352943910/","date":"08-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"卷积神经网络的演化（4）-- 轻量化","path":"2832407222/","date":"08-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"卷积神经网络的演化（3）-- 增强卷积模块","path":"997595469/","date":"08-20","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"卷积神经网络的演化（2）-- 网络加深","path":"2320071567/","date":"08-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"卷积神经网络的演化（1）-- 早期探索","path":"264349064/","date":"08-18","excerpt":"LeNet可以说是CNN的开端，麻雀虽小，但五脏俱全，卷积层、池化层、全连接层，这些都是现代CNN网络的基本组件。而AlexNet是另一个具有历史意义的网络结构，它的成功表示了深度学习重回历史舞台。"},{"title":"用卷积神经网络提取图像特征","path":"3130706902/","date":"08-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv制作全景图","path":"536247407/","date":"08-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现图像矫正（2）","path":"2897130415/","date":"08-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现图像矫正（1）","path":"3189447745/","date":"08-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"关键点匹配与单应性变换","path":"3612763462/","date":"08-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像角点特征之Harris、SIFT、SURF、ORB","path":"2333914337/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像形状特征之HOG、LBP、Haar","path":"2969359875/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现圆检测","path":"3760115698/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现车道线检测","path":"572269927/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像几何特征之霍夫变换","path":"1909086326/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"从图像边缘到物体轮廓","path":"562429633/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于空间域的边缘检测","path":"2883311391/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于频率域的边缘检测","path":"3929430975/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像的傅里叶变换","path":"1106727177/","date":"08-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现条形码区域分割","path":"432783440/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现图像阴影去除","path":"3452502093/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现图像去雾","path":"600921206/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现图像修复","path":"4246668038/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv生成手绘风格图片","path":"1028906181/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv做录屏功能","path":"3061608956/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv做视频分割","path":"3198933444/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用opencv实现形态学操作","path":"1071734474/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"opencv图像缩放方法总结","path":"483554643/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"opencv灰度处理方法总结","path":"260751545/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像处理工具opencv","path":"2833041697/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用scikit-image实现伽马校正","path":"494723945/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像处理工具scikit-image","path":"4060199006/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用pillow制作抖音晃眼特效","path":"1330746008/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"图像处理工具pillow","path":"2459068642/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"感知哈希算法与图像指纹","path":"3989745012/","date":"08-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"计算机视觉的发展历程","path":"2761930239/","date":"08-12","excerpt":"尽管人们对计算机视觉这门学科的起始时间和发展历史有不同的看法，但应该说， 1982年马尔( David Marr )《视觉》（Marr, 1982）一书的问世，标志着计算机视觉成为了一门独立学科。计算机视觉40多年的发展中，尽管人们提出了大量的理论和方法，但总体上说，计算机视觉经历了4个主要历程。即： 马尔计算视觉、主动和目的视觉、多视几何与分层三维重建和基于学习的视觉。"},{"title":"计算机视觉的几个概念","path":"4032015104/","date":"08-12","excerpt":"一、CG、CV、IP计算机图像学（CG）：计算机图形学是一门使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示。计算机视觉（CV）：计算机视觉是一门研究如何使机器”看”的科学，更进一步的说，就是是指用摄影机和电脑代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图形处理，试图建立能够从图像或者多维数据中获取信息的人工智能系统。图像处理（IP）：在图像科学中，图像处理是用任何信号处理等数学操作处理图像的过程，输入时图像（摄影图像或者视频帧），输出是图像或者与输入图像有关的特征、参数的集合。"},{"title":"使用sparrow框架训练多层全连接神经网络","path":"2992216862/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用sparrow框架训练多分类逻辑回归模型","path":"3924247555/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"使用sparrow框架训练二分类逻辑回归模型","path":"1946337279/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用python搭建一个深度学习框架（6）","path":"2999122932/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用python搭建一个深度学习框架（5）","path":"2692174874/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用python搭建一个深度学习框架（4）","path":"415970175/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用python搭建一个深度学习框架（3）","path":"2233207750/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用python搭建一个深度学习框架（2）","path":"1033923747/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用python搭建一个深度学习框架（1）","path":"789955405/","date":"07-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"PyTorch的预训练模型","path":"3528851071/","date":"07-14","excerpt":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import torchimport torchvisionfrom PIL import Imagefrom torchvision import transforms as Timport matplotlib.pyplot as pltimport cv2COCO_INSTANCE_CATEGORY_NAMES = [ '__background__', 'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'N/A', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'N/A', 'backpack', 'umbrella', 'N/A', 'N/A', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle', 'N/A', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'N/A', 'dining table', 'N/A', 'N/A', 'toilet', 'N/A', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'N/A', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush']model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)model.eval()def get_prediction(img_path, threshold): img = Image.open(img_path) transform = T.Compose([T.ToTensor()]) img = transform(img) pred = model([img]) pred_class = [COCO_INSTANCE_CATEGORY_NAMES[i] for i in list(pred[0]['labels'].numpy())] pred_boxes = [[(i[0], i[1]), (i[2], i[3])] for i in list(pred[0]['boxes'].detach().numpy())] pred_score = list(pred[0]['scores'].detach().numpy()) pred_t = [pred_score.index(x) for x in pred_score if x &gt; threshold][-1] pred_boxes = pred_boxes[:pred_t+1] pred_class = pred_class[:pred_t+1] return pred_boxes, pred_classdef object_detection_api(img_path, threshold=0.5, rect_th=3, text_size=3, text_th=3): boxes, pred_cls = get_prediction(img_path, threshold) img = cv2.imread(img_path) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) for i in range(len(boxes)): cv2.rectangle(img, (int(boxes[i][0][0]), int(boxes[i][0][1])), (int(boxes[i][1][0]), int(boxes[i][1][1])), color=(0, 255, 0), thickness=rect_th) cv2.putText(img, pred_cls[i], (int(boxes[i][0][0]), int(boxes[i][0][1])), cv2.FONT_HERSHEY_SIMPLEX, text_size, (0, 255, 0), thickness=text_th) plt.figure(figsize=(20, 30)) plt.imshow(img) plt.xticks([]) plt.yticks([]) plt.show()object_detection_api('timg.jpg', rect_th=2, text_th=1, text_size=1)"},{"title":"PyTorch的可视化工具","path":"2357133008/","date":"07-13","excerpt":"张量的可视化显示单张图片123456789import torch as tfrom torchvision import transformsfrom matplotlib import pyplot as pltto_pil = transforms.ToPILImage()img = to_pil(t.randn(3, 64, 64)) # 随机噪声plt.imshow(img)plt.show()"},{"title":"PyTorch的数据工具","path":"3106047642/","date":"07-13","excerpt":"在解决深度学习问题的过程中，往往需要花费大量的精力去处理数据，包括图像、文本、语音或其他二进制数据等。数据的处理对训练神经网络来说十分重要，良好的数据处理不仅会加速模型训练，也会提高模型效果。"},{"title":"深度学习开发框架PyTorch（10）-- 追加训练","path":"1488374188/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（9）-- 模型保存和复用","path":"2830397174/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（8）-- GPU的使用","path":"1879516578/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（7）-- 权值初始化","path":"3987967061/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（6）-- 神经网络训练","path":"735884790/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（5）-- 查看模型参数","path":"637271919/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（4）-- 神经网络建模","path":"3618086368/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（3）-- Autograd","path":"4004236938/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（2）-- Tensor","path":"3437024737/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"深度学习开发框架PyTorch（1）","path":"871523251/","date":"07-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"人工神经网络（3）-- 有导师学习","path":"1666558727/","date":"07-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"人工神经网络（2）-- 无导师学习","path":"263107895/","date":"07-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"人工神经网络（1）","path":"900580798/","date":"07-10","excerpt":"神经网络其实是一个非常宽泛的称呼，它包括两类，一类是用计算机的方式去模拟人脑，这就是我们常说的ANN（人工神经网络），另一类是研究生物学上的神经网络，又叫生物神经网络。对于计算机人士而言，肯定是研究前者。人工神经网络（Artificial Neural Network，即ANN），是20世纪80 年代以来人工智能领域兴起的研究热点。它从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。在工程与学术界也常直接简称为神经网络或类神经网络。最近十多年来，人工神经网络的研究工作不断深入，已经取得了很大的进展，其在模式识别、智能机器人、自动控制、预测估计、生物、医学、经济等领域已成功地解决了许多现代计算机难以解决的实际问题，表现出了良好的智能特性。"},{"title":"将模型打包为pmml文件","path":"3556708910/","date":"06-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"将模型打包为http接口","path":"2851159423/","date":"06-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"机器学习模型部署","path":"2989210513/","date":"06-25","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"自动化建模工具pycaret","path":"64493560/","date":"06-20","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"树模型可视化工具dtreeviz","path":"96412920/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"机器学习模型解释库SHAP","path":"3936215762/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"各种回归模型拟合效果可视化","path":"454380017/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"各种分类模型分类效果可视化","path":"2155035100/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"各种降维模型效果可视化","path":"240768076/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型评估之回归评估（2）","path":"403295581/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型评估之回归评估（1）","path":"180118195/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型评估之分类评估（4）","path":"2841759239/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型评估之分类评估（3）","path":"884405950/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型评估之分类评估（2）","path":"2349502939/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型评估之分类评估（1）","path":"2663333429/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型评估之聚类评估","path":"4160778094/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型超参数调节（3）","path":"336413927/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型超参数调节（2）","path":"2897290114/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"模型超参数调节（1）","path":"3187969132/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"集成学习框架LightGBM","path":"1952789364/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"集成学习框架XGBoost","path":"2242506817/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"构建复杂模型之集成学习（4）","path":"1075947376/","date":"06-19","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"构建复杂模型之集成学习（3）","path":"3723927497/","date":"06-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"构建复杂模型之集成学习（2）","path":"1699412140/","date":"06-17","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"构建复杂模型之集成学习（1）","path":"2013222722/","date":"06-16","excerpt":"什么是集成学习前面介绍了一系列的算法，每个算法有不同的适用范围，例如有处理线性可分问题的，有处理线性不可分问题。在现实世界的生活中，常常会因为“集体智慧”使得问题被很容易解决，那么问题来了，在机器学习问题中，对于一个复杂的任务来说，能否将很多的机器学习算法组合在一起，这样计算出来的结果会不会比使用单一的算法性能更好？这样的思路就是集成学习方法。严格意义上来说，这不算是一种机器学习算法，而更像是一种优化手段或者策略，它通常是结合多个简单的弱机器学习算法，去做更可靠的决策。有人把它称为机器学习中的“屠龙刀”，非常万能且有效，集成模型是一种能在各种的机器学习任务上提高准确率的强有力技术，集成算法往往是很多数据竞赛关键的一步，能够很好地提升算法的性能。哲学思想为“三个臭皮匠赛过诸葛亮”。拿分类问题举个例，直观的理解，就是单个分类器的分类是可能出错，不可靠的，但是如果多个分类器投票，那可靠度就会高很多。现实生活中，我们经常会通过投票，开会等方式，以做出更加可靠的决策。集成学习就与此类似。集成学习就是有策略的生成一些基础模型，然后有策略地把它们都结合起来以做出最终的决策。集成学习又叫多分类器系统。集成方法是由多个较弱的模型集成模型组，一般的弱分类器可以是DT, SVM, NN, KNN等构成。其中的模型可以单独进行训练，并且它们的预测能以某种方式结合起来去做出一个总体预测。该算法主要的问题是要找出哪些较弱的模型可以结合起来，以及如何结合的方法。这是一个非常强大的技术集，因此广受欢迎。集成算法家族强大，思想多样，但是好像没有同一的术语，很多书本上写得也不一样， 不同的学者有不同的描述方式，最常见的一种就是依据集成思想的架构分为 Bagging ,Boosting, Stacking三种。"},{"title":"特征存储的几种方法","path":"676116113/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"在管道中用sklearn-pandas实现变换映射","path":"2456611099/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用管道机制处理数据","path":"1751667036/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"自动化特征工程featuretools","path":"1249655105/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"特征工程中的时间戳处理技巧","path":"2508415001/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"特征工程（4）","path":"346913227/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"特征工程（2）","path":"835069463/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"特征工程（3）","path":"2306490738/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"特征工程（1）","path":"594774521/","date":"06-15","excerpt":"特征工程是机器学习，甚至是深度学习中最为重要的一部分，也是课本上最不愿意讲的一部分，特征工程往往是打开数据密码的钥匙，是数据科学中最有创造力的一部分。有这么一句话在业界广泛流传，数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。那特征工程到底是什么呢？顾名思义，其本质是一项工程活动，目的是最大限度地从原始数据中提取特征以供算法和模型使用。举一个非常简单的例子，现在出一非常简答的二分类问题题，请你使用逻辑回归设计一个身材分类器，输入数据X为身高和体重，标签为Y为身材等级（胖，不胖）。这里显然不能单纯的根据体重来判断一个人胖不胖，姚明很重，他胖吗？显然不是。针对这个问题，一个非常经典的特征工程是构造BMI指数，BMI=体重/(身高^2)。这样，通过BMI指数就能非常清晰地帮助我们刻画一个人身材如何。甚至，你可以抛弃原始的体重和身高数据。"},{"title":"类别不平衡问题及其解决方法","path":"3692179964/","date":"06-15","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"训练集、测试集、验证集与划分方法","path":"1712749388/","date":"06-15","excerpt":"一、训练集、测试集、验证集在机器学习预测任务中，我们需要对模型泛化误差进行评估，选择最优模型。如果我们把所有数据都用来训练模型的话，建立的模型自然是最契合这些数据的，测试表现也好。但换了其它数据集测试这个模型效果可能就没那么好了。为了防止过拟合，就需要将数据集分成训练集、验证集、测试集。"},{"title":"Sklearn生成模拟数据集","path":"333399540/","date":"06-15","excerpt":"随机样本生成1234567891011121314151617181920212223import matplotlib.pyplot as pltfrom sklearn.datasets import make_classification# make_classificationX, Y = make_classification( n_samples=100, # 样本个数 n_features=20, # 特征个数 n_informative=2, # 多信息特征的个数 n_redundant=2, # 冗余信息，informative特征的随机线性组合 n_repeated=0, # 重复信息，随机提取n_informative和n_redundant 特征 n_classes=2, # 分类类别 n_clusters_per_class=2, # 某一个类别是由几个cluster构成的 weights=None, flip_y=0.01, class_sep=1.0, hypercube=True, shift=0.0, scale=1.0, shuffle=True, random_state=None)plt.scatter(X[:, 0], X[:, 1], marker='o', c=Y)plt.show()"},{"title":"Sklearn中自带的数据集","path":"458375869/","date":"06-15","excerpt":"iris数据集鸢尾花数据集，一个非常经典的用于多分类任务的数据集。1234567891011121314from sklearn.datasets import load_iris# 加载数据集iris = load_iris()# 数据的条数和维数n_samples,n_features = iris.data.shapeprint(\"Number of sample:\", n_samples)print(\"Number of feature\", n_features)print(iris.data[0]) # 第一个样例print(iris.data.shape)print(iris.target.shape)print(iris.target)"},{"title":"跨行业数据挖掘标准流程CRISP-DM","path":"4058837575/","date":"06-15","excerpt":"Sklearn是python用于数据挖掘以及机器学习的利器，但是其功能庞杂，初学者很难理清脉络，快速学习其应用精髓。而CRISP-DM（跨行业数据挖掘标准流程）是一套受业界普遍认可、使用范围广的数据挖掘最佳实践方法论，有助于帮助理解Sklearn在数据挖掘/机器学习各个环节的功能实现。下面来介绍一下什么是CRISP-DM。"},{"title":"机器学习库Sklearn","path":"206541007/","date":"06-15","excerpt":"Sklearn是利用python进行机器学习常用的第三方库，这个库对一些常用的机器学习方法进行了封装，这样在进行机器学习时只需调用Sklearn里的模块就可以完成大多数机器学习任务。此外，Sklearn还提供了特征提取、数据处理、模型评估等功能。"},{"title":"监督学习之树模型（4）","path":"457375658/","date":"06-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之树模型（3）","path":"2257962771/","date":"06-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之树模型（2）","path":"1042915446/","date":"06-13","excerpt":"决策树算法的基本思想是以信息熵为度量构造一棵值下降最快的树。因此需要理解如下几个概念。熵为了理解熵，必须讲一点物理学。热力学第二定律表达了有很多种解释，有一种最容易懂：能量转换的时候，大部分能量会转换成预先设定的状态，比如热能变成机械能、电能变成光能。但是，还有一部分能量会生成新的状态。状态多，就是可能性多，表示比较混乱；状态少，就是可能性少，相对来说就比较有秩序。因此，能量转换会让系统的混乱度增加，熵就是系统的混乱度。“熵”是一种无序程度的量度，意思是越混乱越无规律熵值就越大，反之熵值越小。"},{"title":"监督学习之树模型（1）","path":"748425112/","date":"06-12","excerpt":"决策树算法在机器学习中算是很经典的一个算法系列了，被认为是监督学习方法中最好的并且是最常用的方法之一，特别适合作为集成学习的基学习器。我们可以将决策树看作是if- then规则的集合，使用决策树模型进行预测的过程就相当于对if - then规则进行判断，那我们可以想到如果if -then规则越多，也就是决策树越复杂，那么预测所需要的时间越长，所以为了不断优化决策树的决策过程，我们需要合理的构建决策树，那么如何来选择if - then的决策规则至关重要。"},{"title":"监督学习之概率模型（2）","path":"2415872126/","date":"06-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之概率模型（1）","path":"2638931856/","date":"06-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之线性模型（5）-- 多重共线性问题","path":"812675695/","date":"06-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之线性模型（4）-- 支持向量机","path":"2741252079/","date":"06-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之线性模型（3）-- 逻辑回归","path":"4009209616/","date":"06-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之线性模型（2）-- 线性回归","path":"2151433473/","date":"06-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"监督学习之线性模型（1）","path":"3720461171/","date":"06-08","excerpt":"一、线性关系与非线性关系1、线性关系与线性方程线性关系：两个变量之间为一次方函数关系 / 在数学上可以理解为一阶导数为常数的函数 , 就称它们之间存在线性关系。（正比例关系是线性关系中的特例）线性方程：代数方程如y = 3x + 9的自变量和因变量之间就是线性关系。这种方程的图像为直线或平面。"},{"title":"监督学习之最近邻算法","path":"3816199004/","date":"06-07","excerpt":"一、概念理解K最近邻（kNN，k-NearestNeighbor）分类算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。我们可以假设在一个N维空间中有很多个点，然后这些点被分为几个类。相同类的点，肯定是聚集在一起的，它们之间的距离相比于和其他类的点来说，非常近。如果现在有个新的点，我们不知道它的类别，但我们知道了它的坐标，那只要计算它和已存在的所有点的距离，然后以最近的k个点的多数类作为它的类别，则完成了它的分类。所以kNN算法无非就是计算一个未知点与所有已经点的距离，然后根据最近的k个点类别来判断它的类别。简单，粗暴，实用。"},{"title":"非监督学习之聚类算法（6）-- 基于核函数","path":"472934610/","date":"06-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之聚类算法（5）-- 基于模型","path":"3163495312/","date":"06-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之聚类算法（5）-- 基于网格","path":"3569756237/","date":"06-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之聚类算法（4）-- 基于密度","path":"3591053090/","date":"06-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之聚类算法（3）-- 基于层次","path":"1279112432/","date":"06-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之聚类算法（2）-- 基于划分","path":"827544404/","date":"06-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之聚类算法（1）","path":"1475824648/","date":"06-01","excerpt":"一、聚类的概念聚类是一种无监督学习，根据样本的内在相似性/距离，将大量未知标记的样本集划分为多个类别，使得同一个类别内的样本相似度较大（距离较小），而不同类别间的样本相似度较小（距离较大）。样本相似度比较见python实现相似性/距离的度量"},{"title":"非监督学习之降维算法（3）-- 非线性映射","path":"316631656/","date":"05-30","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之降维算法（2）-- 线性映射","path":"3254685080/","date":"05-30","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"非监督学习之降维算法（1）","path":"3216970386/","date":"05-30","excerpt":"一、降维的概念降维就是指采用某种映射方法，将原高维空间中的数据点映射到低维度的空间中。1、降维的必要性 多重共线性预测变量之间相互关联。多重共线性会导致解空间的不稳定，从而可能导致结果的不连贯 高维空间本身具有稀疏性一维正态分布有68%的值落于正负标准差之间，而在十维空间上只有0.02%。 过多的变量会妨碍查找规律的建立 仅在变量层面上分析可能会忽略变量之间的潜在联系。例如几个预测变量可能落入仅反映数据某一方面特征的一个组内。"},{"title":"【数值优化】启发搜索之群体智能（6）-- 人工蜂群","path":"662258907/","date":"05-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】启发搜索之群体智能（5）-- 人工鱼群","path":"1725330928/","date":"05-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】启发搜索之群体智能（4）-- 菌群","path":"1757248802/","date":"05-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】启发搜索之群体智能（3）-- 粒子群","path":"4063302824/","date":"05-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】启发搜索之群体智能（2）-- 蚁群","path":"2452775632/","date":"05-14","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】启发搜索之群体智能（1）","path":"1057156556/","date":"05-14","excerpt":"演化式计算是一种共享名词，系指达尔文进化论的”适者生存，不适者淘汰”，以此观念来实际模拟自然界演化过程所建立的演算方式，例如早期Holland教授的遗传算法（Genetic Algorithms）。然而，后进者开始将演化重心转移到动物的群体行为上，提出了群体智能优化算法，代表是意大利学者Dorigo、Maniezzo等人于20世纪90年代提出来一种蚁群算法(Ant Colony Algorithm)。他们在研究蚂蚁觅食的过程中，发现单个蚂蚁的行为比较简单，但是蚁群整体却可以体现一些智能的行为。例如蚁群可以在不同的环境下，寻找最短到达食物源的路径。这是因为蚁群内的蚂蚁可以通过某种信息机制实现信息的传递。后又经进一步研究发现，蚂蚁会在其经过的路径上释放一种可以称之为“信息素”的物质，蚁群内的蚂蚁对“信息素”具有感知能力，它们会沿着“信息素”浓度较高路径行走，而每只路过的蚂蚁都会在路上留下“信息素”，这就形成一种类似正反馈的机制，这样经过一段时间后，整个蚁群就会沿着最短路径到达食物源了。概括来说，群体智能Swarm Intelligence）优化算法主要模拟了在昆虫、兽群、鸟群和鱼群之中发现的通过合作方式寻找食物的群体行为。其核心思想就是若干个简单个体构成一个群体，通过合作、竞争、交互与学习等机制表现出高级和复杂的功能，所以群体智能可以在没有集中控制并且缺少全局信息和模型的前提下，仍能够完成复杂问题的求解。其求解过程为对求解变量进行随机初始化，经过迭代，计算目标函数的输出值。群体智能优化算法不依赖于梯度信息，对待求解问题无连续、可导等要求，使得该类算法既适应连续型数值优化，也适应离散型组合优化。"},{"title":"【数值优化】启发搜索之遗传算法","path":"1906011939/","date":"05-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】启发搜索之模拟退火法","path":"3232431097/","date":"05-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】局部搜索之牛顿法","path":"2587627408/","date":"05-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】局部搜索之改进的梯度下降法","path":"3906581751/","date":"05-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】局部搜索之梯度下降法","path":"2675795306/","date":"05-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【数值优化】局部搜索之随机游走","path":"421976375/","date":"05-13","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】非线性规划（3）","path":"1265805227/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】非线性规划（2）","path":"4090413262/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】非线性规划（1）","path":"3782962976/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】线性规划之整数规划（2）","path":"370591374/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】线性规划之整数规划（1）","path":"77818208/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】线性规划（5）","path":"400066455/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】线性规划（4）","path":"2942623986/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】线性规划（3）","path":"850647115/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】线性规划（2）","path":"2316287790/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"【公式求解】线性规划（1）","path":"2562330816/","date":"05-12","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"最优化算法概述与分类","path":"4079683076/","date":"05-12","excerpt":"一、概念最优化方法是一种数学方法，它是研究在给定约束之下如何寻求某些因素(的量)，以使某一(或某些)指标达到最优的一些学科的总称。我们每个人都会在我们的生活或者工作中遇到各种各样的最优化问题，比如每个企业和个人都要考虑的一个问题“在一定成本下，如何使利润最大化”等。"},{"title":"基于元胞自动机的模拟（2）","path":"3108332892/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于元胞自动机的模拟（1）","path":"2884684466/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于偏微分方程的物理模拟（2）","path":"1418550454/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于偏微分方程的物理模拟（1）","path":"1178137432/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于常微分方程的物理模拟（2）","path":"2594715854/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于常微分方程的物理模拟（1）","path":"2283640608/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于蒙特卡罗方法的模拟（4）","path":"3518866277/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于蒙特卡罗方法的模拟（3）","path":"1282055132/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于蒙特卡罗方法的模拟（2）","path":"4107730105/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"基于蒙特卡罗方法的模拟（1）","path":"3865269079/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"数值模拟的概念","path":"964984116/","date":"05-11","excerpt":"科学研究方法经历了实验研究、解析计算、数值模拟计算的演化。数值模拟的概念数值模拟也叫计算机模拟，是一种依靠计算机的结合有限元或有限容积的概念通过数值计算和图像显示的方法。"},{"title":"微分方程建模实例（2）","path":"324210296/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"微分方程建模实例（1）","path":"31891862/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"微分方程建模方法（3）","path":"925682446/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"微分方程建模方法（2）","path":"2408623211/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"微分方程建模方法（1）","path":"2636448645/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"微分方程建模步骤","path":"2133750126/","date":"05-11","excerpt":"一、微分方程模型在实际问题中经常需要寻求某个变量y随另一变量t的变化规律，这个函数关系常常不能直接求出。然而有时容易建立包含变量及导数在内的关系式，即建立变量能满足的微分方程，从而通过求解微分方程对所研究的问题进行解释说明。"},{"title":"高级数理统计之生存分析","path":"1045684655/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"AB实验（2）","path":"771972184/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"AB实验（1）","path":"1018622902/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"统计推断之假设检验","path":"4096267862/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"统计推断之参数估计","path":"2131735375/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用scipy.stats模块生成概率分布","path":"54995268/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"常见概率分布的Python实现","path":"2761267969/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"解读三大抽样分布","path":"244439616/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"抽样分布和中心极限定理","path":"2101841077/","date":"05-11","excerpt":"由于样本是随机样本，所以样本统计量也是一个随机变量。而只要是随机变量就一定有相应的概率分布。我们把样本估计量的分布称为统计量分布，也称抽样分布。以样本平均数为例，一般说样本平均数的抽样分布如何如何，这里，样本平均数被当成了一个随机变量来看待。对于初学者来说，这确实是比较反直觉的。为何样本平均数可以被当做一个随机变量？因为样本平均数是依赖样本计算得出的：每抽取一个样本都可以计算出一个样本平均数，而且这些样本平均数或多或少都会有些差异。由此，样本平均数会随着抽样的不同而随机变动。只是现实生活中我们一般只抽取一个样本，计算一个样本平均数，因此，会觉得样本平均数不变。如果按照相同的样本容量，相同的抽样方式，反复地抽取样本，每次可以计算一个平均数，所有可能样本平均数所形成的分布，就是样本平均数的抽样分布。我们不妨用身高的这个例子还原一下这个过程。假设我们现在想了解中国成年男子的身高情况，通过简单随机抽样获取了一个1000人的样本，计算出样本均数为1.76（米），样本标准差为0.1（米）。现在，我们按照同样的方法重复抽100次，每次都抽取1000人。在这个过程中我们实际一共调查了10万人，不过这10万人以1000人为一批被分成了100个样本，而每一个样本都可以计算一个样本平均数，假设分别为1.76，1.72，1.69，1.77……1.75。由此，我们一共获得了100个样本平均数，从而可以对这100个数求平均数和标准差，于是就得到了样本平均数的平均数和标准差（这个标准差一般称为样本平均数的标准误）。为什么要这样做？为什么不直接一次性调查10万人，而要绕这么个圈子？很简单，这里100次的重复抽样仅仅是辅助大家理解，现实中出于成本的考虑，往往只会抽取一次。更重要的是，统计理论告诉我们即使只抽样一次也是极具价值的，这个理论就是中心极限定理（central limit theorem）。这个定理的逻辑很简单：在任意总体中随机抽取一个样本量为n的样本，如果样本容量较大（通常大于30即可），那么通过这个样本计算的样本平均数近似服从正态分布。中心极限定理的核心思想可以很好地由下面这幅图来表达："},{"title":"样本统计量","path":"156010943/","date":"05-11","excerpt":"人类的认知能力仅对少量的对象比较敏感，所以从大量数据中找出共性并不是人类所擅长的。为了解决这一问题，归纳和概括大量数据的指标便出现了，这就是统计量的由来。一、集中趋势度量"},{"title":"统计抽样","path":"1444542467/","date":"05-11","excerpt":"通常情况下，把总体全部作为样本进行调查研究的成本是极为高昂的。在对大量的人口对象进行统计的时候就有这个问题。对几十亿条数据进行多维度的统计分析，这样的计算，即使是用计算机来进行，也有无法忽略的成本。此外，检测本身可能存在破坏性。例如，在工业品出厂检测中，很多情况下，被测对象在被拆解后无法再流向市场，这就形成了一种生产过程中的损失。所以，有相当多的统计调查都是通过抽样来进行的，因为这种方式更为经济，而且可行性更高。为了让抽取的样本对总体有足够好的代表性，在生产中，最常使用的方法就是概率抽样（Probability Sampling），也叫随机抽样。有的时候也会使用非概率抽样（Non-Probability Sampling）的方法。"},{"title":"统计的数据来源","path":"2033033779/","date":"05-11","excerpt":""},{"title":"统计就是统共合计","path":"3253743127/","date":"05-11","excerpt":""},{"title":"统计学的起源和发展","path":"3890402212/","date":"05-11","excerpt":"统计学的创立时期（古典统计学）统计学的萌芽在欧洲。17世纪中叶至18世纪中叶是统计学的创立时期。在这一时期，统计学理论初步形成了一定的学术派别，主要有国势学派（记述学派）和政治算术学派。"},{"title":"高等数学问题的数值解（6）--解微分方程","path":"3722685205/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的数值解（5）--线性代数问题","path":"1602032039/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的数值解（4）--解代数方程","path":"866863522/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的数值解（3）--数值积分","path":"1427328198/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的数值解（2）--近似计算函数导数","path":"1174195358/","date":"05-11","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的数值解（1）--求函数极值点","path":"1162778082/","date":"05-10","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"数值工具库初探","path":"1663713069/","date":"05-09","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用SymPy解几何数学题","path":"1481737364/","date":"05-08","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（8）--解微分方程","path":"2518575541/","date":"05-08","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（7）--线性代数问题","path":"130995456/","date":"05-07","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（6）--解代数方程","path":"1331529423/","date":"05-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（5）--积分问题","path":"755630497/","date":"05-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（4）--级数的求和","path":"1683879557/","date":"05-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（3）--泰勒级数展开","path":"1165002537/","date":"05-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（2）--求导数","path":"701004068/","date":"05-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"高等数学问题的符号解（1）--求极限","path":"3165059136/","date":"05-01","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用SymPy做符号函数画图","path":"3735481833/","date":"04-18","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"符号工具库初探","path":"3971056152/","date":"04-17","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"符号计算和数值计算","path":"2888870150/","date":"04-15","excerpt":"符号计算与数值计算1、符号计算符号计算以符号对象和符号表达式作为运算对象，给出解析解。符号计算不受误差累积问题的影响。符号计算的指令简单。符号计算耗时长，占用硬件资源多。"},{"title":"使用basemap绘制世界著名景点","path":"3482205118/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"地震分布数据可视化","path":"4286034115/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"绘制Lissajous曲线","path":"2037580546/","date":"04-06","excerpt":""},{"title":"使用Pandas进行数据可视化","path":"4154416359/","date":"04-06","excerpt":"箱型图12345678import numpy as npimport pandas as pdimport matplotlib.pyplot as pltdf = pd.DataFrame(np.random.rand(8, 4), columns=['A','B','C','D'])df.plot.box()plt.show()"},{"title":"用dash搭建数据可视化应用（2）","path":"2298058774/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"用dash搭建数据可视化应用（1）","path":"2588686328/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"stylecloud绘制词云图","path":"170371706/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pyecharts绘制词云图","path":"1403610760/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"prettymaps制作海报级地图","path":"479990116/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pyecharts地理信息可视化（4） -- 迁移地图","path":"3864111089/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pyecharts地理信息可视化（3） -- 绘制动态轨迹","path":"3114561084/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pyecharts地理信息可视化（2） -- 绘制3D地图","path":"1069369896/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"pyecharts地理信息可视化（1） -- 绘制2D地图","path":"3396331510/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"plotly绘制空气质量热力图","path":"1098163711/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"plotly系列（5）-- 高级封装","path":"3064667984/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"plotly系列（4）-- 绘制三维图表","path":"3175990280/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"plotly系列（3）-- 绘制二维图表","path":"3445115429/","date":"04-06","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"plotly系列（2）-- 多子图绘制功能","path":"1110247238/","date":"04-05","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"plotly系列（1）","path":"240032966/","date":"04-04","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"matplotlib系列（6）-- 高级封装","path":"2346482165/","date":"04-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"matplotlib系列（5）-- 动态图绘制","path":"2191078521/","date":"04-03","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"matplotlib系列（4）-- 绘制三维图表","path":"223911437/","date":"04-02","excerpt":"这里有东西被加密了，需要输入密码查看哦。"},{"title":"matplotlib系列（3）-- 绘制二维图表","path":"2102202400/","date":"04-02","excerpt":"matplotlib提供了常见二维图表的绘制。一、数据分布1、直方图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#-*- coding:utf-8 -*-import matplotlib as mplimport matplotlib.pyplot as pltimport numpy as np# 正常显示中文plt.rcParams['font.sans-serif']=['SimHei']# 正常显示负号plt.rcParams['axes.unicode_minus']=False # print(plt.style.available)plt.style.use('seaborn-paper')def plot_hist(title, x): ''' 绘制直方图 ''' fig, ax = plt.subplots(figsize=(16,10), dpi= 80) # 创建一个画板 # 标题、坐标轴设定 plt.title(title, fontsize=22) plt.xlabel('x', fontsize=16, fontfamily='sans-serif',fontstyle='italic') plt.ylabel('y', fontsize=16, fontfamily='sans-serif',fontstyle='italic') # 设置坐标轴刻度线 # plt.yticks([1,5,8,15,24], [r'$really\\ bad$',r'$bad$',r'$normal$',r'$good$',r'$really\\ good$']) # 是否显示网格 ax.grid(False) # 坐标轴的一些属性设定 # ax.set_aspect('equal') # 坐标轴等比例 ax.xaxis.set_tick_params(labelsize=16, colors='g') # 坐标轴刻度格式 ax.xaxis.set_major_locator(plt.MultipleLocator(1)) # 坐标轴刻度间隔1 ax.yaxis.tick_right() # y轴坐标布局位置 ax.yaxis.set_tick_params(labelsize=16) # 移动坐标轴 ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) # 将bottom即是x坐标轴设置到y=0的位置 ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) # 将left即是y坐标轴设置到x=0的位置 # 消除边框 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') # 绘图 ax.hist(x, bins=25, # 分段数量 width=0.2, # 宽度 alpha=0.5, # 不透明度 #facecolor='white', # 柱形填充颜色 #hatch='/', # 图形填充形状，可选['/', '', '|', '-', '+', 'x', 'o', 'O', '.', '*'] #edgecolor='darkblue' # 边缘颜色 ) # plt.savefig(\"./\"+title+\".png\") # 保存图片 plt.show()x = np.random.normal(0,1,1000)plot_hist('测试图', x)"},{"title":"matplotlib系列（2）-- 多子图绘制功能","path":"1768920104/","date":"04-02","excerpt":"在matplotlib下，一个画布（Figure）对象可以包含多个子图（Axes），可以使用subplot()快速绘制。1、subplot介绍1subplot(numRows, numCols, plotNum)"},{"title":"matplotlib系列（1）","path":"2931818261/","date":"04-02","excerpt":"Matplotlib是Python中最常用的可视化工具之一, 它比较底层，可定制性强、图表资源丰富。一、Matplotlib三层结构1、容器层容器层主要由Canvas、Figure、Axes组成。Canvas是位于最底层的，在绘图的过程中充当画板的角色，即放置画布（Figure）的工具。Figure是Canvas上方的第一层，也是用户可操作的最低层级，在绘图过程中充当画布的角色。Axes是Canvas上方的第二层，在绘图过程总相当于画布上的绘图区的角色。"},{"title":"HiveSQL时间差计算","path":"2761996663/","date":"03-11","excerpt":""},{"title":"Hive中导入数据和导出数据","path":"2101370445/","date":"03-11","excerpt":"一、向Hive导入数据先在Hive里面创建好表，如下：12345678910hive&gt; create table user &gt; (id int, &gt; name string, &gt; age int, &gt; tel string) &gt; ROW FORMAT DELIMITED &gt; FIELDS TERMINATED BY '\\t' &gt; STORED AS TEXTFILE;OKTime taken: 2.832 seconds"},{"title":"数据仓库表命名规范","path":"3908968593/","date":"03-10","excerpt":"俗话说无规矩不成方圆。我们在搭建数据平台的时候，需要先制定好各种规范，越早越好，并且不断的监督大家是否按照约定执行。一旦大家自由发挥，想要再次统一或者重构就非常的困难，会浪费很大的人力成本和时间成本，因此在这里总结一下数据仓库的表命名规范。一般来说表名需要见名知意，通过表名就可以知道它是哪个业务域，干嘛用的，什么粒度的数据。特殊用途的表有一些特殊的命名法则。"},{"title":"数据仓库基础知识","path":"3149234292/","date":"03-10","excerpt":"一、什么是数据仓库数据仓库，英文名称为DataWarehouse，可简写为DW或DWH。数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它出于分析性报告和决策支持目的而创建。为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。"},{"title":"Redis和MongoDB的区别","path":"536692031/","date":"03-10","excerpt":"Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活。"},{"title":"NoSQL数据库的四大类型","path":"1680660831/","date":"03-10","excerpt":"一般将NoSQL数据库分为四大类：键值(Key-Value)存储数据库、列存储数据库、文档型数据库和图形(Graph)数据库。它们的数据模型、优缺点、典型应用场景如下表所示。"},{"title":"SQL优化法则","path":"689124555/","date":"03-10","excerpt":"SQL作为关系型数据库的标准语言，是IT从业人员必不可少的技能之一。SQL本身并不难学，编写查询语句也很容易，但是想要编写出能够高效运行的查询语句却有一定的难度。查询优化是一个复杂的工程，涉及从硬件到参数配置、不同数据库的解析器、优化器实现、SQL语句的执行顺序、索引以及统计信息的采集等，甚至应用程序和系统的整体架构。下面介绍几个关键法则，可以帮助我们编写高效的SQL查询；尤其是对于初学者而言，这些法则至少可以避免我们写出性能很差的查询语句。"},{"title":"谈谈SQL和NoSQL数据库","path":"905644568/","date":"03-10","excerpt":"一、概念1、SQL数据库SQL (Structured Query Language) 数据库，指关系型数据库。关系型数据库的内部设计由关系算法决定，这些系统需要预先定义一个模式(schema)和数据要遵守的类型。SQL是与这些系统交互的标准方式。主要代表：SQL Server，Oracle，MySQL(开源)，PostgreSQL(开源)。"},{"title":"python实现阳历转农历","path":"1627615815/","date":"03-09","excerpt":""},{"title":"python实现视频转gif","path":"1548099232/","date":"03-09","excerpt":""},{"title":"python实现键盘和鼠标监控","path":"1590459571/","date":"03-09","excerpt":"一、安装pynput1pip install pynput二、使用pynput监控键盘123456789101112from pynput import keyboarddef on_press(key): print(f'&#123;key&#125; :pushed')def on_release(key): if key == keyboard.Key.esc: return Falsewith keyboard.Listener(on_press=on_press, on_release=on_release) as lsn: lsn.join()"},{"title":"python实现音乐高潮部分提取","path":"350398703/","date":"03-09","excerpt":"一、安装pychorus1pip install pychorus二、使用pychorus注意：确保代码目录中存在ffmpeg.exe提取单首歌的高潮部分123from pychorus import find_and_output_choruschorus_start_sec = find_and_output_chorus(\"D:\\\\music\\\\记念.mp3\", \"记念_high.wav\", 10)"},{"title":"python实现Hex转RGB","path":"798196981/","date":"03-09","excerpt":""},{"title":"python提取图片配色","path":"3243528101/","date":"03-09","excerpt":""},{"title":"python快速找出大文件","path":"3142828576/","date":"03-09","excerpt":""},{"title":"python实现根据名字判断性别","path":"1184044635/","date":"03-09","excerpt":""},{"title":"python实现手机归属地查询","path":"1602212504/","date":"03-09","excerpt":""},{"title":"实用imageio库制作gif","path":"408190280/","date":"03-09","excerpt":""},{"title":"用python实现指定日期上的推算","path":"1411023687/","date":"03-09","excerpt":""},{"title":"用python获取任意一个月的天数","path":"3401181658/","date":"03-09","excerpt":""},{"title":"web开发框架Flask","path":"2399825675/","date":"03-09","excerpt":"一、安装1pip install Flask二、快速上手12345678910111213141516from flask import Flaskfrom flask_cors import CORSdef create_app(): app = Flask(__name__) # 创建app实例 CORS(app, supports_credentials=True) # 设置跨域 return appapp = create_app()@app.route(\"/\")def hello_world(): return \"&lt;p&gt;Hello, World!&lt;/p&gt;\"if __name__ == '__main__': app.run(port=5000, debug=True)"},{"title":"表情符解析库emoji","path":"1609805869/","date":"03-09","excerpt":"1234567import emojiresult1 = emoji.emojize('it is :grinning_face:')print(result1)result2 = emoji.demojize('😀')print(result2)"},{"title":"更高级的时间处理","path":"1144000143/","date":"03-09","excerpt":"一、arrow时间对象1、将时间戳转化为arrow对象1234import arrowprint(arrow.get(1367900664))print(arrow.get(1367900664.152325))"},{"title":"python探测字符串编码","path":"3219136697/","date":"03-09","excerpt":""},{"title":"python实现字符串模糊匹配","path":"3715461618/","date":"03-09","excerpt":"一、fuzz模块该模块下主要介绍四个函数（方法），分别为：简单匹配（Ratio）、非完全匹配（Partial Ratio）、忽略顺序匹配（Token Sort Ratio）和去重子集匹配（Token Set Ratio）"},{"title":"python解析拼音","path":"413064707/","date":"03-09","excerpt":""},{"title":"python解析电话号码","path":"1950103062/","date":"03-09","excerpt":"提取手机号1234567import phonenumberstxt = '我是xxx，今年x岁，电话是15332198671，我的朋友的电话是15311892310'm = phonenumbers.PhoneNumberMatcher(txt, 'CN')for x in m: print(x.raw_string)"},{"title":"python利用一对列表生成字典","path":"15586382/","date":"03-09","excerpt":"方法一：12345keys = ['a','b','c','d','e'] values = [1,2,3,4,5] d = dict(zip(keys, values))print(d)"},{"title":"python利用字典对列表中元素个数计数","path":"2320429104/","date":"03-09","excerpt":"方法一：利用字典的get函数get表示根据字典的key取它的value值，如果该key不存在，则value值会默认为get的第二个参数。12345values = [1,2,3,2,3,1,4]value_cnt = &#123;&#125;for value in values: value_cnt[value] = value_cnt.get(value, 0) + 1print(value_cnt)"},{"title":"更优雅的日志方案","path":"1286361839/","date":"03-09","excerpt":"一、CMRESHandler12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import loggingimport sysfrom os import makedirsfrom os.path import dirname, existsfrom cmreslogging.handlers import CMRESHandlerloggers = &#123;&#125;LOG_ENABLED = True # 是否开启日志LOG_TO_CONSOLE = True # 是否输出到控制台LOG_TO_FILE = True # 是否输出到文件LOG_TO_ES = False # 是否输出到 ElasticsearchLOG_PATH = './runtime.log' # 日志文件路径LOG_LEVEL = 'DEBUG' # 日志级别LOG_FORMAT = '%(levelname)s - %(asctime)s - process: %(process)d - %(filename)s - %(name)s - %(lineno)d - %(module)s - %(message)s' # 每条日志输出格式ELASTIC_SEARCH_HOST = 'eshost' # Elasticsearch HostELASTIC_SEARCH_PORT = 9200 # Elasticsearch PortELASTIC_SEARCH_INDEX = 'runtime' # Elasticsearch Index NameAPP_ENVIRONMENT = 'dev' # 运行环境，如测试环境还是生产环境def get_logger(name=None): global loggers if not name: name = __name__ if loggers.get(name): return loggers.get(name) logger = logging.getLogger(name) logger.setLevel(LOG_LEVEL) # 输出到控制台 if LOG_ENABLED and LOG_TO_CONSOLE: stream_handler = logging.StreamHandler(sys.stdout) stream_handler.setLevel(level=LOG_LEVEL) formatter = logging.Formatter(LOG_FORMAT) stream_handler.setFormatter(formatter) logger.addHandler(stream_handler) # 输出到文件 if LOG_ENABLED and LOG_TO_FILE: # 如果路径不存在，创建日志文件文件夹 log_dir = dirname(LOG_PATH) if not exists(log_dir): makedirs(log_dir) # 添加 FileHandler file_handler = logging.FileHandler(LOG_PATH, encoding='utf-8') file_handler.setLevel(level=LOG_LEVEL) formatter = logging.Formatter(LOG_FORMAT) file_handler.setFormatter(formatter) logger.addHandler(file_handler) # 输出到 Elasticsearch if LOG_ENABLED and LOG_TO_ES: # 添加 CMRESHandler es_handler = CMRESHandler(hosts=[&#123;'host': ELASTIC_SEARCH_HOST, 'port': ELASTIC_SEARCH_PORT&#125;], # 可以配置对应的认证权限 auth_type=CMRESHandler.AuthType.NO_AUTH, es_index_name=ELASTIC_SEARCH_INDEX, # 一个月分一个 Index index_name_frequency=CMRESHandler.IndexNameFrequency.MONTHLY, # 额外增加环境标识 es_additional_fields=&#123;'environment': APP_ENVIRONMENT&#125; ) es_handler.setLevel(level=LOG_LEVEL) formatter = logging.Formatter(LOG_FORMAT) es_handler.setFormatter(formatter) logger.addHandler(es_handler) # 保存到全局 loggers loggers[name] = logger return loggerlogger = get_logger('123')logger.debug('this is a message')"},{"title":"计算复利小程序","path":"2928744736/","date":"03-09","excerpt":""},{"title":"汇率转换小程序","path":"921704930/","date":"03-09","excerpt":""},{"title":"进制转换","path":"2110329172/","date":"03-09","excerpt":""},{"title":"用Wget下载文件","path":"1590980796/","date":"03-09","excerpt":"从网络上提取数据是数据科学家的重要任务之一。Wget是一个免费的实用程序，可以用于从网络上下载非交互式的文件。它支持HTTP、HTTPS和FTP协议，以及通过HTTP的代理进行文件检索。由于它是非交互式的，即使用户没有登录，它也可以在后台工作。所以下次当你想要下载一个网站或者一个页面上的所有图片时，wget可以帮助你。"},{"title":"用Python自动解压各种压缩文件","path":"429265522/","date":"03-09","excerpt":"编写一个Python程序，每次下载压缩包形式的文件后，自动将内部文件解压到当前文件夹后将压缩包删除。提到压缩文件就要分不同压缩格式进行讨论，主要有以下4种：.gz：即gzip，通常只能压缩一个文件。.tar：本质上不是压缩工具而是打包工具，可以跟.gz配合形成.tar.gz的打包压缩格式。.zip：和.tar.gz很类似但可以打包压缩多个文件。.rar：打包压缩文件，最初用于DOS。"},{"title":"替换不能用于文件名的字符","path":"392677030/","date":"03-09","excerpt":""},{"title":"异常重试","path":"1495236933/","date":"03-09","excerpt":"retrying是一个Python的重试包，可以用来自动重试一些可能运行失败的程序段。retrying提供一个装饰器函数retry，被装饰的函数就会在运行失败的条件下重新执行，默认只要一直报错就会不断重试。"},{"title":"轻量级定时任务调度库Schedule","path":"1717000303/","date":"03-09","excerpt":""},{"title":"使用Pandas爬取简单表格数据（1）","path":"3166673290/","date":"03-09","excerpt":""},{"title":"python爬虫（基础版）","path":"2954111759/","date":"03-09","excerpt":""},{"title":"使用UUID库生成唯一ID","path":"777249297/","date":"03-09","excerpt":"UUID（全称为Universally Unique IDentifier）是128位的唯一标识符，通常由32字节的字符串表示。它可以通过MAC地址、时间戳、命名空间、随机数、伪随机数来保证生成ID的时间和空间的唯一性。UUID主要有五个算法，也就是五种方法来实现："},{"title":"python生成二维码","path":"1775177327/","date":"03-09","excerpt":"二维码简称 QR Code（Quick Response Code），学名为快速响应矩阵码，是二维条码的一种，由日本的 Denso Wave 公司于1994年发明。现随着智能手机的普及，已广泛应用于平常生活中，例如商品信息查询、社交好友互动、网络地址访问等等。qrcode模块是Github上的一个开源项目，提供了生成二维码的接口。qrcode默认使用PIL库用于生成图像。由于生成 qrcode 图片需要依赖 Python 的图像库安装方法："},{"title":"python实现控制台进度条","path":"3299880956/","date":"03-09","excerpt":"对于开发或者运维来说，使用Python去完成一些跑批任务，或者做一些监控事件是非常正常的情况。那么如何有效地监控任务的进度？除了在任务中加上Log外，还能不能有另一种方式来了解任务进展到哪一步了呢？这就是今天我们来了解的内容——进度条。"},{"title":"用python实现相似性的度量","path":"4227751902/","date":"03-05","excerpt":"相似性度量，即综合评定两个事物之间相近程度的一种度量。两个事物越接近，它们的相似性度量也就越大，而两个事物越疏远，它们的相似性度量也就越小。相似性度量的给法种类繁多，一般根据实际问题进行选用。"},{"title":"python开发技巧之性能测量","path":"3343212228/","date":"03-05","excerpt":"一、使用 time粗粒度的计算时间123456from time import timebegin = time()job = [x**2 for x in range(1, 100000, 3)]end = time()print('used &#123;:.5&#125; s'.format(end-begin))"},{"title":"Pandas循环提速攻略","path":"1121761621/","date":"03-04","excerpt":"一、标准循环————101.6秒DataFrame是具有行和列的Pandas对象。如果使用循环，需要遍历整个对象。Python不能利用任何内置函数，而且速度很慢。"},{"title":"Pandas数据操作归纳总结","path":"1318714917/","date":"03-02","excerpt":"Pandas建立在NumPy之上，旨在与许多其他第三方库完美地集成在科学计算环境中。它的两个主要数据结构是Series（1维）和DataFrame（2维）。一、Pandas数据结构：一维数组(Series)"},{"title":"Numpy矩阵操作短代码","path":"3661249452/","date":"03-01","excerpt":"创建一个5x5的矩阵，并设置值1,2,3,4落在其对角线下方位置1234import numpy as npZ = np.diag(1+np.arange(4),k=-1)print(Z)"},{"title":"Numpy数组操作短代码","path":"3834646878/","date":"03-01","excerpt":"如何用一个生成10个整数的函数来构建数组12345678import numpy as npdef generate(): for x in range(10): yield xZ = np.fromiter(generate(), dtype=float, count=-1)print (Z)"},{"title":"纯python实现Numpy部分高级运算","path":"3390462876/","date":"03-01","excerpt":""},{"title":"NumPy数据操作归纳总结","path":"1634276553/","date":"03-01","excerpt":"NumPy是一个在Python中做科学计算的核心库，它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。一、NumPy数据结构：数组(Arrays)1、创建数组"},{"title":"更新pip源至国内镜像","path":"3975138079/","date":"03-01","excerpt":"在使用Python的时候经常需要安装各种模块，而pip是很强大的模块安装工具，但是由于国外官方pypi经常被墙，导致不可用，所以我们最好是将自己使用的pip源更换一下，这样就能解决被墙导致的装不上库的烦恼。"},{"title":"虚拟环境管理pipenv","path":"2431510997/","date":"03-01","excerpt":"安装1pip install pipenv基本用法创建虚拟环境123mkdir democd demopipenv install创建虚拟环境的命令执行之后会在当前目录自动生成Pipfile和Pipfile.lock两个文件，他们主要是用来管理包的。前者负责保存库的信息和python版本的信息，后者负责保存库的哈希值。"},{"title":"虚拟环境管理virtualenvwrapper","path":"610702636/","date":"03-01","excerpt":"在使用virtualenv创建虚拟环境时，是直接生成于当前目录，若存在多个环境时，系统里面的虚拟环境便很难管理，而使用virtualenvwrapper创建的虚拟环境，均会创建于一个固定的目录里面，这样创建的虚拟目录便都集中到里一起，方便我们管理，并且存在很多方便的命令，可随时进入到虚拟环境不需要进入到指定的目录里面执行activate。"},{"title":"虚拟环境管理virtualenv","path":"3314936231/","date":"03-01","excerpt":"安装1pip install virtualenv基本用法1、创建虚拟环境1virtualenv 环境名当前目录下会生成一个多级的文件夹，这便是创建的虚拟环境2、进入虚拟环境"},{"title":"python设计模式：代理模式","path":"1346035936/","date":"03-01","excerpt":"在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。代理模式在日常生活中很常见，比如，你去杂货店买一个插座，而不是去生产插座的工厂去买。再比如，你去访问某个网站，你并没有访问权限，但你可以通过代理去访问这个网站，然后代理再把内容传给你。"},{"title":"python设计模式：备忘录模式","path":"1817080092/","date":"03-01","excerpt":"备忘录模式说通俗点就相当于一个游戏存档，一般我们玩游戏打BOSS前都会保存一下，如果打BOSS失败了就读取存档再来一遍，这里面涉及三个对象，英雄：你控制的游戏角色，存档：用来保存英雄的状态数据，存档管理员：帮你执行保存和读取的工作。"},{"title":"python设计模式：策略模式","path":"1502107777/","date":"03-01","excerpt":""},{"title":"python设计模式：观察者模式","path":"897415007/","date":"03-01","excerpt":""},{"title":"python设计模式：适配器模式","path":"1520181411/","date":"03-01","excerpt":"通常情况下，原系统的代码要么无法获取（如库等）要么难以冒险重构（如运行5年以上的老旧系统牵一发而动全身），在设计中使用适配器模式，可以保证在不修改原系统代码的前提下，实现新需求与原系统的对接。"},{"title":"python设计模式：建造者模式","path":"1373141365/","date":"03-01","excerpt":"建造者模式（Builder Pattern） 又名生成器模式，是一种对象构建模式。它允许用户只需要指定复杂对象的类型就可以构建它们，而无须知道其内部的具体构造细节。该模式适用于基本部件不变，而其组合经常变化的场景，例如购物、点餐。"},{"title":"python设计模式：工厂模式","path":"2131976579/","date":"03-01","excerpt":"工厂模式，顾名思义就是我们可以通过一个指定的”工厂”获得需要的”产品”，在设计模式中主要用于抽象对象的创建过程，让用户可以指定自己想要的对象而不必关心对象的实例化过程，这样做的好处是用户只需通过固定的接口而不是直接去调用类的实例化方法来获得一个对象的实例，隐藏了实例创建过程的复杂度，解耦了生产实例和使用实例的代码，降低了维护的复杂性。"},{"title":"python设计模式：单例模式","path":"3658216142/","date":"03-01","excerpt":"单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个AppConfig的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建AppConfig对象的实例，这就导致系统中存在多个AppConfig的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似AppConfig这样的类，我们希望在程序运行期间只存在一个实例对象。"},{"title":"python中深浅拷贝的讲解","path":"2964116366/","date":"03-01","excerpt":"拷贝，原则上就是把数据分离，使得源数据和副本数据的修改互不影响。在Python中，拷贝是有深、浅之分的，如果使用的时候不注意，就可能产生意外的结果。其实这个是由于共享内存导致的结果。"},{"title":"几个常用的装饰器","path":"184380600/","date":"03-01","excerpt":"任务超时退出使请求超时就不再继续了，直接抛出超时错误，避免等太久。123456789101112131415161718192021import functoolsfrom concurrent import futuresimport timeexecutor = futures.ThreadPoolExecutor(1)def timeout(seconds): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): future = executor.submit(func, *args, **kw) return future.result(timeout=seconds) return wrapper return decorator@timeout(1)def task(a, b): time.sleep(1.2) return a+btask(2, 3)"},{"title":"python中装饰器的写法","path":"832999311/","date":"03-01","excerpt":"装饰器本质上是一个Python函数（返回值是一个函数对象），它可以让其他函数在不需要任何代码变动的前提下增加额外功能。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。"},{"title":"python标准库之其他","path":"3139771177/","date":"03-01","excerpt":"bisectbisect是二分法的意思。bisect库常用于有序序列的查找和插入。1、查找123456789import bisect a = [1,4,6,8,12,15,20]position = bisect.bisect(a, 13)print(position) # 用可变序列内置的insert方法插入a.insert(position, 13)print(a)"},{"title":"python标准库之邮件","path":"3489945850/","date":"03-01","excerpt":""},{"title":"python标准库之测试框架","path":"279306606/","date":"03-01","excerpt":"python标准库中的unittest模块提供了一系列创建和运行测试的工具。测试用例TestCase每一个单独的测试方法都叫做一个TestCase，我们给待测的代码A一个input，A返回给我们一个response，我们需要check一下response是不是所期望的，就能判断出A写的对不对。这整个测试过程都在TestCase中执行。"},{"title":"python标准库之函数式编程（4）","path":"3631705794/","date":"03-01","excerpt":"collections 模块包含了除list、dict、和tuple之外的容器数据类型，如counter、deque、defaultdict、orderdict、namedtuple。"},{"title":"python标准库之函数式编程（3）","path":"1168135803/","date":"03-01","excerpt":"operator模块输出一系列对应Python内部操作符的函数。一、常见的函数操作 操作 语法 函数 加法 a + b add(a, b) 连接 seq1 + seq2 concat(seq1, seq2) 包含测试 obj in seq contains(seq, obj) 除法 a / b truediv(a, b) 除法 a // b floordiv(a, b) 按位与 a &amp; b and_(a, b) 按位异或 a ^ b xor(a, b) 按位求反 ~ a invert(a) 按位求或 a b 求幂 a ** b pow(a, b) 身份测试 a is b is_(a, b) 身份测试 a is not b is_not(a, b) 索引分配 obj[k] = v setitem(obj, k, v) 索引删除 del obj[k] delitem(obj, k) 得出索引键值 obj[k] getitem(obj, k) 左移 a &lt;&lt; b lshift(a, b) 求模 a % b mod(a, b) 乘法 a * b mul(a, b) 矩阵乘法 a @ b matmul(a, b) 求负值（数学） - a neg(a) 求负值（逻辑） not a not_(a) 求正值 + a pos(a) 右移 a &gt;&gt; b rshift(a, b) 片段分配 seq[i: j] = values setitem(seq, slice(I, j), values) 片段删除 del seq[i, j] delitem(seq, slice(I, j)) 得到片段 swq[i : j] getitme(seq, slice(i, j)) 字符串格式化 s % obj mod(s, obj) 减法 a - b sub(a, b) 真值测试 obj truth(obj) 排序 a &lt; b lt(a, b) 排序 a &lt;= b le(a, b) 相等 a == b eq(a, b) 不等 a !- b ne(a, b) 排序 a &gt;= b ge(a, b) 排序 a &gt; b ge(a, b)"},{"title":"python标准库之函数式编程（2）","path":"4246483230/","date":"03-01","excerpt":"functools 模块提供了一些非常有用的高阶函数。所谓高阶函数就是说一个可以接受函数作为参数或者以函数作为返回值的函数，因为Python中函数也是对象，因此很容易支持这样的函数式特性。"},{"title":"python标准库之函数式编程（1）","path":"4020870896/","date":"03-01","excerpt":"itertools 模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，我们可以通过 for 循环来遍历取值，也可以使用 next() 来取值。"},{"title":"python标准库之序列化","path":"4293631904/","date":"03-01","excerpt":"python标准库中有两个模块可以将对象转换为一种可传输或存储的格式（这个过程被称为序列化），一种是pickle（应用最广泛），一种是json（在基于web的应用较为常见）。"},{"title":"python标准库之数据加密","path":"2294369657/","date":"03-01","excerpt":"python标准库中的hashlib模块提供了字符加密功能，包含MD5和SHA的加密算法，具体支持md5、sha1、sha224、sha256、sha384、sha512等算法。该模块在用户登录认证方面应用广泛，对文本加密也很常见。"},{"title":"python标准库之数据压缩","path":"3284691747/","date":"03-01","excerpt":"python标准库提供了对通用压缩标准的支持。一、zlib压缩标准12345678910111213141516171819202122232425262728293031323334353637import zlib def zlib_demo1(): ''' 对类字节对象进行压缩和解压 ''' data = b'test' # data = bytes('test', encoding = \"utf8\") # data = str.encode('test') com_bytes = zlib.compress(data) print(\"压缩后的数据: \", com_bytes) decom_bytes = zlib.decompress(com_bytes) print(\"解压后的数据: \", decom_bytes)def zlib_demo2(): ''' 对数据流进行压缩和解压 ''' # 数据流压缩 with open(\"org_file.txt\", \"rb\") as read, open(\"com_file.txt\", \"wb\") as write: com = zlib.compressobj(level=9, memLevel=9) for data in read: write.write(com.compress(data)) write.write(com.flush()) # 对数据流进行解压 with open(\"com_file.txt\", \"rb\") as read, open(\"decom_file.txt\", \"wb\") as write: decom = zlib.decompressobj() for data in read: write.write(decom.decompress(data)) write.write(decom.flush())zlib_demo1()zlib_demo2()"},{"title":"python标准库之互联网访问","path":"2064757086/","date":"03-01","excerpt":"python标准库中的urllib模块用来模拟发送http请求。一、简单请求1、不传递参数（get请求）12345678910111213141516171819import urllib.requestresponse = urllib.request.urlopen('https://www.baidu.com', timeout=1) # 设置超时时间, 单位为秒print(\"查看访问URL地址: \\n\", response.geturl())print(\"查看响应结果(成功返回ok)：\\n\", response.msg)print(\"查看响应状态码1(http status)：\\n\", response.status)print(\"查看响应状态码2(http status)：\\n\", response.getcode())print(\"查看 response 的返回类型：\", type(response))print(\"查看头部信息1(http header)：\\n\", response.info())print(\"查看头部信息2(http header)：\\n\", response.getheaders())print(\"输出头部属性信息：\", response.getheader(\"Server\"))page = response.read()print(\"输出网页源码:\",page.decode('utf-8'))"},{"title":"python标准库之随机","path":"1223517890/","date":"03-01","excerpt":"python标准库中的random模块可以用来生成（伪）随机数。随机数不仅可以用于数学用途，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。一、生成随机数"},{"title":"python标准库之数学运算","path":"781075673/","date":"03-01","excerpt":"python标准库的math模块实现了许多对浮点数的数学运算函数。 1、符号操作1234567import matha = 1.67b = -2.6print(math.fabs(b)) # 返回 b 的绝对值print(math.copysign(a, b)) # 返回与 b 同号的 a 值"},{"title":"python标准库之正则表达式","path":"940767634/","date":"03-01","excerpt":"正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。re 模块使 Python 语言拥有全部的正则表达式功能。"},{"title":"python标准库之日志","path":"2006239921/","date":"03-01","excerpt":"日志对于系统开发的开发、调试和运行整个过程中都起着很重要的作用，调试阶段需要查看日志来明确问题所在，运行阶段如果程序崩溃，日志可以记录程序崩溃的相关原因。python的标准库里的logging模块从Python2.3开始支持，包含四大组件:"},{"title":"python标准库之队列","path":"184768324/","date":"03-01","excerpt":"在python标准库中的queue模块实现了面向多生产线程、多消费线程的队列。一、队列的三种形态1、FIFO队列（先进先出）123456789import queueq = queue.Queue()for i in range(5): q.put(i)while not q.empty(): print(q.get())"},{"title":"python标准库之时间与日期","path":"3093767214/","date":"03-01","excerpt":"python具有良好的时间和日期管理功能，主要涉及time和datetime两个模块。time包基于C语言的库函数(library functions)。datetime包是基于time包的一个高级包， 为我们提供了多一层的便利。"},{"title":"python标准库之系统","path":"1367091492/","date":"03-01","excerpt":"python标准库的os模块提供了一种方便的使用操作系统函数的方法，而sys模块则提供了对由解释器使用或维护的变量的访问和与解释器进行交互的函数。简单来说，os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口；sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。"},{"title":"python魔术方法","path":"3095104256/","date":"03-01","excerpt":"在Python中，被双下滑线包围起来的方法（定义在类中）叫魔术方法（Magic Method），比如我们最常见的init()就是一个典型的魔术方法。一、构造和初始化"},{"title":"python内置函数","path":"2296141139/","date":"03-01","excerpt":"Python内置的函数及其用法。一、数学运算操作12345678910111213141516171819# 对浮点数进行四舍五入求值print(round(4.6))print(round(1.1314926, 5))# 求数值的绝对值print(abs(-5)) # 返回两个数值的商和余数print(divmod(10, 3)) # 返回两个数值的幂运算值或其与指定整数的模值print(pow(2, 3))print(pow(2, 3, 5))print(pow(2, 3)%5)# 返回可迭代对象中的元素中的最大值或者所有参数的最大值print(max([1, 2, 3, 4]))# 返回可迭代对象中的元素中的最小值或者所有参数的最小值print(min([1, 2, 3, 4]))# 对元素类型是数值的可迭代对象中的每个元素求和print(sum([1, 2, 3, 4]))print(sum((1, 2, 3, 4)))print(sum((1, 2, 3, 4), -10))"},{"title":"哈希算法","path":"585302133/","date":"02-13","excerpt":"最简单的哈希算法可以用求余方式取哈希值（哈希地址），不同的哈希地址存放不同的数据，由此，需要提供键-值（Key-Value）关系的哈希表，键记录哈希地址、值记录数据。"},{"title":"经典算法之搜索","path":"3582642768/","date":"02-11","excerpt":"搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找。"},{"title":"经典算法之排序","path":"844968213/","date":"02-11","excerpt":"所谓排序，就是将数据分为有序区和无序区，通过对无序区元素的调整并扩展有序区，最后达到所有元素都有序的状态。在排序界，常见（或者说常用）的算法主要有冒泡排序、直接插入排序、选择排序、希尔排序、堆排序、快速排序、归并排序。一些不太常用但是比较有技巧性的排序有：堆排序、桶排序、基数排序、位图排序、外部排序（一般结合hash然后多路归并）等。"},{"title":"经典算法之字符串匹配","path":"317112244/","date":"02-10","excerpt":"1、BF算法BF（Brute Force）算法就是朴素的暴力匹配。BF算法的基本思想是从主串的start位置开始与模式串进行匹配，如果相等，则继续比较后续字符，如果不相等则模式串回溯到开始位置，主串回溯到start+1位置，继续进行比较直至模式串的所有字符都已比较成功，则匹配成功，或者主串所有的字符已经比较完毕，没有找到完全匹配的子串，则匹配失败。"},{"title":"设计思想之分治","path":"3590913587/","date":"02-09","excerpt":"什么是分治分治法的思想是分而治之，就是把一个复杂问题分成两个或更多相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，将最后子问题的解合并得到原问题的解。因为问题小到一定规模可以更好解决，将一个问题分解若干个相同问题，再利用分解出若干子问题的解可以合并为该问题的解。这个技巧是很多高效算法的基础。"},{"title":"设计思想之动态规划","path":"1388475946/","date":"02-09","excerpt":""},{"title":"设计思想之贪心","path":"2068435046/","date":"02-09","excerpt":"什么是贪心所谓贪心法是指在对问题求解时总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。应用贪心的示例硬币找零问题"},{"title":"设计思想之穷举","path":"2801208867/","date":"02-09","excerpt":"什么是穷举穷举就是逐一列举问题所涉及的所有情况。穷举法常用于解决”是否存在”和”有多少种可能”的问题。应用穷举的示例白鸡百钱问题123456789# 已知公鸡5元一只，母鸡3元一只，小鸡一元3只。现用100元钱买100只鸡，问：公鸡母鸡小鸡各几只？for i in range(100): for j in range(100): for k in range(100): number = i + j +k price = i*5 + j*3 + k*(1/3) if (number &lt;= 100) &amp; (price &lt;= 100) &amp; (k % 3 == 0): print(\"There are %dck, %d hen, and %d chick\" % (i,j,k))"},{"title":"设计思想之递归","path":"2309853115/","date":"02-09","excerpt":""},{"title":"算法的性能评价","path":"1433815660/","date":"02-09","excerpt":"一个算法的优劣往往通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个方面。时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。"},{"title":"算法的表示","path":"67727918/","date":"02-09","excerpt":"使用自然语言描述就是用我们的口头语言来表示算法，这样很多算法难以描述，不利于发展交流。使用流程图描述流程图是用一些图框来表示各种类型的操作，在框内写出各个步骤，然后用带箭头的线把它们连接起来，以表示执行的先后顺序。用图形表示算法，直观形象，易于理解。"},{"title":"算法的分类","path":"1947804170/","date":"02-09","excerpt":"按照设计思想分类递推算法，递归算法，穷举算法，贪心算法，分治算法，动态规划算法，迭代算法等。按照应用分类按照算法的应用领域，可以分为基本算法，数据结构相关算法，几何算法，图论算法，规划算法，数值分析算法，加密解密算法，排序算法，查找算法，并行算法，数值算法……"},{"title":"算法的实现过程","path":"2031916383/","date":"02-09","excerpt":"算法的主要实现过程包括明确需求、设计算法、代码实现、验证及完善。明确需求在设计算法前，分析需求，确认有哪些限制条件，是非常重要的。它可以帮助明确算法设计的主方向。"},{"title":"什么是算法","path":"250562244/","date":"02-09","excerpt":"算法，从字面意义上解释，就是用于计算的方法，通过该这种方法可以达到预期的计算结果。目前，被广泛认可的算法专业定义是：算法是模型分析的一组可行的，确定的，有穷的规则。通俗的说，算法也可以理解为一个解题步骤，由一些基本运算和规定的顺序构成。但是从计算机程序设计的角度看，算法由一系列求解问题的指令构成，能根据规范的输入，在有限的时间内获得有效的输出结果。算法代表了用系统的方法来描述解决问题的一种策略机制。"},{"title":"【leetcode】图 Graph","path":"518471523/","date":"02-09","excerpt":"1、leetcode997：找到小镇的法官在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。如果小镇的法官真的存在，那么："},{"title":"【leetcode】树 Tree","path":"1890313194/","date":"02-08","excerpt":"1、leetcode100：相同的树给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Bnode: '''二叉树的节点''' def __init__(self, root, left=None, right=None): self.root = root self.left = left self.right = rightdef getBTreewithBFS(l): '''给定二叉树的层序遍历, 重建该二叉树''' if l[0]: root = Bnode(l[0]) nodes = [root] id = 1 while nodes and id &lt; len(l): node = nodes[0] # 依次为每个节点分配子节点 node.left = Bnode(l[id]) if l[id] else None nodes.append(node.left) node.right = Bnode(l[id+1]) if id&lt;len(l)-1 and l[id+1] else None nodes.append(node.right) id+=2 # 每次取出两个节点 nodes.pop(0) return root else: return Nonedef PrintBTree(root): '''打印二叉树, 从顶到底''' tmp = [] result = [] if root == None: return result tmp.append(root) while tmp: newNode = tmp.pop(0) if newNode == None: result.append(None) else: result.append(newNode.root) if newNode.left or newNode.right: tmp.append(newNode.left) tmp.append(newNode.right) return result#################################################################def isSameTree(p, q): # 先判断是否全为空，是则返回；再判断是否有一个为空，是则返回，再判断两个值是否相等 if not p and not q: return True elif p == None or q == None: return False elif p.root != q.root: return False return isSameTree(p.left,q.left) and isSameTree(p.right,q.right)t1 = getBTreewithBFS([1,3,2])t2 = getBTreewithBFS([1,3,2])print(isSameTree(t1, t2))"},{"title":"【leetcode】队列 Queue","path":"1409509696/","date":"02-07","excerpt":"1、leetcode346：数据流中的移动平均值给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算其所有整数的移动平均值。示例:MovingAverage m = new MovingAverage(3);m.next(1) = 1m.next(10) = (1 + 10) / 2m.next(3) = (1 + 10 + 3) / 3m.next(5) = (10 + 3 + 5) / 3"},{"title":"【leetcode】栈 Stack","path":"2090050131/","date":"02-06","excerpt":"1、leetcode225：用队列实现栈使用队列实现栈的下列操作：push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空"},{"title":"【leetcode】链表 Linked List","path":"3302890261/","date":"02-05","excerpt":"1、leetcode237：删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。示例 1:输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9."},{"title":"【leetcode】字符串 String","path":"3772079612/","date":"02-04","excerpt":"1、Leetcode13：罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000"},{"title":"【Leetcode】数组 Array","path":"4240671852/","date":"02-03","excerpt":"1、leetcode53：最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例：输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。"},{"title":"【leetcode】集合和映射 Set&Map","path":"1468325455/","date":"02-02","excerpt":"1、leetcode1：两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。"},{"title":"Python的内置数据结构","path":"1930468253/","date":"02-01","excerpt":"所谓数据结构，通俗来说就是存储数据的容器。Python内置的基本数据结构可以分成序列、映射以及集合这三类。一、序列（列表、元组和字符串）序列中的每个元素都有自己的编号。"}],"categories":[],"tags":[]}